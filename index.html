<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Water Distribution Management Pro</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>
  <link rel="stylesheet" href="./css/app.css"/>
    
    .btn.warning:hover {
      background: #ffe0b2;
    }
    
    .water-level-container {
      background: linear-gradient(180deg, #e3f2fd 0%, #bbdefb 100%);
      border-radius: 12px;
      padding: 16px;
      margin: 12px 0;
      position: relative;
      overflow: hidden;
    }
    
    .water-tank-visual {
      width: 100%;
      height: 200px;
      position: relative;
      background: #fff;
      border-radius: 8px;
      border: 3px solid #0277bd;
      overflow: hidden;
      box-shadow: inset 0 2px 8px rgba(0,0,0,.1);
    }
    
    .water-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, #03a9f4 0%, #0288d1 100%);
      transition: height .3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: 700;
      font-size: 24px;
      text-shadow: 0 2px 4px rgba(0,0,0,.2);
    }
    
    .water-level-slider {
      width: 100%;
      margin-top: 12px;
      -webkit-appearance: none;
      appearance: none;
      height: 8px;
      border-radius: 4px;
      background: #e0e0e0;
      outline: none;
    }
    
    .water-level-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #0288d1;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,.2);
    }
    
    .water-level-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #0288d1;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,.2);
      border: none;
    }
    
    .household-stats {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      margin: 12px 0;
    }
    
    .household-stats h4 {
      color: #fff;
      border-bottom: 2px solid rgba(255,255,255,.3);
      padding-bottom: 8px;
      margin-bottom: 12px;
    }
    
    .stat-big {
      text-align: center;
      margin: 16px 0;
    }
    
    .stat-big-number {
      font-size: 48px;
      font-weight: 700;
      line-height: 1;
      margin-bottom: 4px;
      text-shadow: 0 2px 8px rgba(0,0,0,.3);
    }
    
    .stat-big-label {
      font-size: 13px;
      opacity: .9;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .stat-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 12px;
      background: rgba(255,255,255,.1);
      border-radius: 8px;
      margin: 8px 0;
    }
    
    .stat-row .label {
      color: rgba(255,255,255,.8);
    }
    
    .stat-row .value {
      color: #fff;
      font-weight: 700;
    }
    
    .valve-hierarchy {
      margin: 12px 0;
    }
    
    .valve-item {
      background: #f8f9fa;
      border-left: 4px solid var(--accent);
      padding: 12px;
      border-radius: 8px;
      margin: 8px 0;
    }
    
    .valve-item.main {
      border-left-color: var(--primary);
      background: #e3f2fd;
    }
    
    .valve-item.sub {
      margin-left: 24px;
      border-left-color: var(--success);
    }
    
    .valve-item.closed {
      opacity: .6;
      border-left-color: var(--danger);
    }
    
    .valve-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .valve-item-title {
      font-weight: 700;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .valve-item-status {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 6px;
      font-weight: 600;
    }
    
    .valve-item-status.open {
      background: #e9f7ee;
      color: var(--success);
    }
    
    .valve-item-status.closed {
      background: #fdeaea;
      color: var(--danger);
    }
    
    .valve-item-info {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }
    
    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      background: rgba(18,22,28,.35);
      backdrop-filter: blur(2px);
    }
    
    .modal.active {
      display: flex;
    }
    
    .modal-content {
      width: min(720px, 95vw);
      max-height: 85vh;
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,.2);
      overflow: hidden;
      animation: modalIn .3s cubic-bezier(.4,0,.2,1);
      display: flex;
      flex-direction: column;
    }
    
    @keyframes modalIn {
      from { opacity: 0; transform: scale(.95); }
      to { opacity: 1; transform: scale(1); }
    }
    
    .modal-header {
      padding: 16px 18px;
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #fafbfc;
      flex-shrink: 0;
    }
    
    .modal-header h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 700;
    }
    
    .close-x {
      border: none;
      background: #f5f7fa;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all .2s;
    }
    
    .close-x:hover {
      background: #e8ecf0;
    }
    
    .modal-body {
      padding: 18px;
      overflow-y: auto;
      flex: 1;
    }
    
    .form-row {
      margin-bottom: 12px;
    }
    
    .form-row label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
      font-weight: 600;
    }
    
    .form-row input, .form-row select, .form-row textarea {
      width: 100%;
      padding: 11px 12px;
      border: 1px solid var(--line);
      border-radius: 10px;
      font-size: 13px;
      color: var(--text);
      background: #fff;
      outline: none;
      transition: all .2s;
      font-family: inherit;
    }
    
    .form-row textarea {
      min-height: 60px;
      resize: vertical;
    }
    
    .form-row input:focus, .form-row select:focus, .form-row textarea:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(30,136,229,.1);
    }
    
    .form-row .error {
      font-size: 11px;
      color: var(--danger);
      margin-top: 4px;
    }
    
    .modal-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 16px;
    }
    
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 3000;
      background: #fff;
      border: 1px solid var(--line);
      color: var(--text);
      padding: 12px 16px;
      border-radius: 10px;
      box-shadow: 0 12px 24px rgba(0,0,0,.15);
      font-size: 13px;
      font-weight: 600;
      display: none;
      animation: toastIn .3s cubic-bezier(.4,0,.2,1);
    }
    
    @keyframes toastIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .zoom {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 1000;
    }
    
    .zoom .tool-btn {
      width: 44px;
      height: 44px;
      border-radius: 10px;
      font-size: 18px;
    }
    
    .manage-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .manage-item {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 12px;
      background: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }
    
    .manage-item-info {
      min-width: 0;
      flex: 1;
    }
    
    .manage-item-title {
      font-weight: 700;
      color: var(--text);
      margin-bottom: 4px;
    }
    
    .manage-item-meta {
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .manage-item-actions {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
    }
    
    .manage-item-actions .btn {
      margin: 0;
      width: auto;
      padding: 8px 12px;
      font-size: 12px;
    }
    
    .tab-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .tab-buttons .btn {
      margin: 0;
    }
    
    .connection-status {
      position: absolute;
      top: 16px;
      right: 60px;
      z-index: 1100;
      background: var(--panel);
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,.08);
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      font-weight: 600;
    }
    
    .connection-status.connected {
      color: var(--success);
    }
    
    .connection-status.disconnected {
      color: var(--danger);
    }
    
    .connection-status .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    
    .connection-status.connected .dot {
      background: var(--success);
    }
    
    .connection-status.disconnected .dot {
      background: var(--danger);
    }
    
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,.95);
      z-index: 5000;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 16px;
    }
    
    .loading-overlay.active {
      display: flex;
    }
    
    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid var(--line);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Hover Tooltip Styles */
    .hover-tooltip {
      position: absolute;
      background: rgba(20, 20, 30, 0.95);
      color: white;
      padding: 12px 16px;
      border-radius: 10px;
      font-size: 12px;
      font-weight: 500;
      z-index: 2000;
      pointer-events: none;
      max-width: 320px;
      min-width: 200px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transform: translateY(-10px);
      opacity: 0;
      transition: opacity 0.2s, transform 0.2s;
    }
    
    .hover-tooltip.active {
      opacity: 1;
      transform: translateY(0);
    }
    
    .hover-tooltip .tooltip-title {
      font-weight: 700;
      font-size: 14px;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .hover-tooltip .tooltip-section {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .hover-tooltip .tooltip-section-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: rgba(255, 255, 255, 0.6);
      font-weight: 700;
      margin-bottom: 6px;
    }
    
    .hover-tooltip .tooltip-row {
      display: flex;
      justify-content: space-between;
      margin-top: 6px;
      padding: 4px 0;
    }
    
    .hover-tooltip .tooltip-label {
      color: rgba(255, 255, 255, 0.7);
      font-size: 11px;
    }
    
    .hover-tooltip .tooltip-value {
      color: white;
      font-weight: 700;
      font-size: 12px;
    }
    
    .hover-tooltip .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
      box-shadow: 0 0 8px currentColor;
    }
    
    .hover-tooltip .status-active {
      background: #4caf50;
      color: #4caf50;
    }
    
    .hover-tooltip .status-inactive {
      background: #f44336;
      color: #f44336;
    }
    
    .hover-tooltip .live-badge {
      display: inline-block;
      background: #4caf50;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 9px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      animation: pulse 2s infinite;
    }
    
    .hover-tooltip .status-active {
      background: #4caf50;
    }
    
    .hover-tooltip .status-inactive {
      background: #f44336;
    }
    
    /* Supply Dashboard Styles */
    .supply-dashboard {
  position: absolute;
  bottom: 20px;
  right: 20px;
  width: 320px;
  background: var(--panel);
  border-radius: 12px;
  box-shadow: 0 6px 20px rgba(0,0,0,.08);
  border: 1px solid var(--line);
  z-index: 1000;
  overflow: hidden;
  transition: right 0.3s cubic-bezier(.4,0,.2,1);
}

.supply-dashboard.shifted {
  right: 500px; /* Moves left when sidebar is open */
}
    .supply-dashboard-header {
      padding: 12px 16px;
      background: #fafbfc;
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .supply-dashboard-title {
      font-size: 14px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .supply-dashboard-body {
      padding: 16px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .supply-region {
      margin-bottom: 16px;
      border: 1px solid var(--line);
      border-radius: 8px;
      overflow: hidden;
    }
    
    .supply-region-header {
      padding: 10px 12px;
      background: #f8f9fa;
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .supply-region-name {
      font-weight: 600;
      font-size: 13px;
    }
    
    .supply-region-stats {
      display: flex;
      gap: 12px;
      font-size: 11px;
    }
    
    .supply-region-body {
      padding: 12px;
    }
    
    .supply-valve {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px dashed #eef2f5;
    }
    
    .supply-valve:last-child {
      border-bottom: none;
    }
    
    .supply-valve-info {
      flex: 1;
    }
    
    .supply-valve-name {
      font-weight: 600;
      font-size: 12px;
    }
    
    .supply-valve-meta {
      font-size: 10px;
      color: var(--muted);
    }
    
    .supply-valve-status {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
    }
    
    .supply-valve-status.open {
      background: #e9f7ee;
      color: var(--success);
    }
    
    .supply-valve-status.closed {
      background: #fdeaea;
      color: var(--danger);
    }
    
    .supply-valve-flow {
      font-size: 12px;
      font-weight: 700;
      color: var(--primary);
    }
    
    .supply-summary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      border-radius: 8px;
      padding: 12px;
      margin-top: 12px;
    }
    
    .supply-summary-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
    }
    
    .supply-summary-row:last-child {
      margin-bottom: 0;
    }
    
    .supply-summary-label {
      font-size: 11px;
      opacity: .9;
    }
    
    .supply-summary-value {
      font-size: 12px;
      font-weight: 700;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .search {
        width: calc(100% - 100px);
      }
      
      .sidebar {
        width: 90vw;
      }
      
      .supply-dashboard {
        width: 90vw;
        right: 5vw;
        bottom: 80px;
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <canvas id="canvas"></canvas>

  <!-- Hover Tooltip -->
  <div id="hoverTooltip" class="hover-tooltip"></div>

  <!-- Supply Dashboard -->
  <div class="supply-dashboard" id="supplyDashboard">
    <div class="supply-dashboard-header">
      <div class="supply-dashboard-title">
        <i class="fas fa-tachometer-alt"></i> Supply Overview
      </div>
      <button class="close-x" id="toggleSupplyDashboard">
        <i class="fas fa-chevron-down"></i>
      </button>
    </div>
    <div class="supply-dashboard-body" id="supplyDashboardBody">
      <!-- Content will be populated by JavaScript -->
    </div>
  </div>

  <div class="connection-status" id="connectionStatus">
    <div class="dot"></div>
    <span id="statusText">Connecting...</span>
  </div>

  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
    <div style="font-weight:600;color:var(--text)">Loading System...</div>
  </div>



  <div class="toolbar">
    
    <button id="toolPipeline" class="tool-btn active" title="Draw pipeline"><i class="fas fa-drafting-compass"></i></button>
    <button id="toolTank" class="tool-btn" title="Add tank"><i class="fas fa-water"></i></button>
    <button id="toolValve" class="tool-btn" title="Add valve"><i class="fas fa-cog"></i></button>
    <button id="toolErase" class="tool-btn" title="Erase pipeline segment"><i class="fas fa-eraser"></i></button>
    <button id="toolManage" class="tool-btn" title="Manage"><i class="fas fa-list"></i></button>
  <!-- <button id="toolImport" class="tool-btn" title="Import data"><i class="fas fa-upload"></i></button> 
    <button id="toolClear" class="tool-btn" title="Clear all"><i class="fas fa-trash"></i></button> -->
    
    <div class="toolbar-separator"></div>
    
    <button id="layerStreet" class="tool-btn layer active" title="Street Map"><i class="fas fa-map"></i></button>
    <button id="layerSatellite" class="tool-btn layer" title="Satellite View"><i class="fas fa-satellite"></i></button>
    <button id="layerDark" class="tool-btn layer" title="Dark Mode"><i class="fas fa-moon"></i></button>
  </div>

  <div class="search">
    <div class="search-bar">
      <i class="fas fa-magnifying-glass" style="color:var(--muted)"></i>
      <input id="searchInput" type="text" placeholder="Search devices, places, or areas..." autocomplete="off"/>
      <button id="searchBtn" class="icon-btn" title="Search"><i class="fas fa-arrow-right"></i></button>
    </div>
    <div class="suggestions" id="suggestions" style="display:none">
      <div class="suggest-list" id="suggestList"></div>
    </div>
  </div>

  <div class="zoom">
    <button id="zoomIn" class="tool-btn" title="Zoom in"><i class="fas fa-plus"></i></button>
    <button id="zoomOut" class="tool-btn" title="Zoom out"><i class="fas fa-minus"></i></button>
  </div>

  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title" id="sidebarTitle"><i class="fas fa-info-circle"></i> Details</div>
      <button class="close-x" id="closeSidebar" title="Close"><i class="fas fa-xmark"></i></button>
    </div>
    <div class="sidebar-body" id="sidebarBody"></div>
  </div>

  <!-- Tank Modal -->
  <div class="modal" id="tankModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="tankModalTitle">Add Tank</h3>
        <button class="close-x" data-close="tankModal"><i class="fas fa-xmark"></i></button>
      </div>
      <div class="modal-body">
  <div class="form-row">
    <label>Tank ID * (Unique identifier)</label>
    <input id="tankId" placeholder="TANK-001" maxlength="50"/>
    <div class="error" id="tankIdError"></div>
  </div>
  <div class="form-row">
    <label>Device ID <small style="color: var(--muted);">(Link to ESP32 device, e.g., DEVICE_001)</small></label>
    <input id="tankDeviceId" placeholder="DEVICE_001" maxlength="50"/>
    <div style="font-size: 11px; color: var(--muted); margin-top: 4px;">
      <i class="fas fa-info-circle"></i> Enter the device ID from your ESP32 (e.g., DEVICE_001). This links the tank to live ultrasonic sensor data.
    </div>
  </div>
  <div class="form-row"><label>Name *</label><input id="tankName" placeholder="OHSR Tank 1"/></div>
  <div class="form-row">
    <label>Type *</label>
    <select id="tankType">
      <option value="OHSR">OHSR (Overhead Storage Reservoir)</option>
      <option value="GSR">GSR (Ground Storage Reservoir)</option>
      <option value="ESR">ESR (Elevated Storage Reservoir)</option>
    </select>
  </div>
  <div class="form-row">
    <label>Shape *</label>
    <select id="tankShape">
      <option value="cylinder">Cylinder (OHSR/ESR)</option>
      <option value="cuboid">Cuboid (GSR)</option>
    </select>
  </div>
  
  <!-- Cylinder dimensions -->
  <div id="cylinderDimensions">
    <div class="form-row">
      <label>Diameter (m) *</label>
      <input id="tankDiameter" type="number" step="0.1" placeholder="10" value="10"/>
    </div>
  <div class="form-row">
    <label>Height (m) *</label>
    <input id="tankHeight" type="number" step="0.1" placeholder="10" value="10"/>
  </div>
  <div class="form-row">
  <label>Sensor Height (m) <small style="color: var(--muted);">(Distance from tank BOTTOM to sensor position)</small></label>
  <input id="tankSensorHeight" type="number" step="0.1" placeholder="Same as height" value="10"/>
  <div style="font-size: 11px; color: var(--muted); margin-top: 4px; background: #e3f2fd; padding: 8px; border-radius: 6px; border-left: 3px solid #2196f3;">
    <i class="fas fa-info-circle"></i> <strong>Important:</strong> Sensor height is measured from the <strong>tank bottom</strong> (not water surface) to where the sensor is mounted. The sensor measures distance DOWN to the water surface.
    <br><br>
    üìè <strong>Example:</strong> If your tank is 10m tall and sensor is at the top: Sensor Height = 10m
    <br>
    üíß <strong>When tank is full:</strong> Distance = 0m (sensor to water = 0), Water Level = 10m
    <br>
    üîª <strong>When tank is empty:</strong> Distance = 10m (sensor to bottom), Water Level = 0m
  </div>
</div>
  </div>
  
  <!-- Cuboid dimensions -->
  <div id="cuboidDimensions" style="display: none;">
    <div class="form-row">
      <label>Length (m) *</label>
      <input id="tankLength" type="number" step="0.1" placeholder="10" value="10"/>
    </div>
    <div class="form-row">
      <label>Breadth (m) *</label>
      <input id="tankBreadth" type="number" step="0.1" placeholder="10" value="10"/>
    </div>
    <div class="form-row">
      <label>Height (m) *</label>
      <input id="tankHeightCuboid" type="number" step="0.1" placeholder="10" value="10"/>
    </div>
  </div>
  
  <div class="form-row">
    <label>Capacity (L) * <small style="color: var(--muted);">(Auto-calculated or manual)</small></label>
    <input id="tankCapacity" type="number" placeholder="20000"/>
    <button type="button" class="btn primary" id="calculateCapacity" style="margin-top: 8px;">
      <i class="fas fa-calculator"></i> Calculate from Dimensions
    </button>
  </div>
  
  <div class="form-row">
    <label>Current Water Level (m) *</label>
    <input id="tankWaterLevel" type="number" step="0.1" placeholder="8.5" max="10"/>
  </div>
  <!-- NEW: Connected Main Valves Section -->
  <div class="form-row">
    <label>Connected Main Valves * (Select all main valves connected to this tank)</label>
    <div style="border: 1px solid var(--line); border-radius: 10px; padding: 12px; background: #f8f9fa; max-height: 200px; overflow-y: auto;" id="mainValvesList">
      <div style="text-align: center; color: var(--muted); padding: 20px;">
        Loading main valves...
      </div>
    </div>
    <div style="font-size: 11px; color: var(--muted); margin-top: 6px;">
      <i class="fas fa-info-circle"></i> Select which main valves receive water from this tank
    </div>
  </div>
  
  <div class="form-row"><label>State</label><input id="tankState" placeholder="Telangana"/></div>
  <div class="form-row"><label>District</label><input id="tankDistrict" placeholder="Mulugu"/></div>
  <div class="form-row"><label>Mandal</label><input id="tankMandal" placeholder="Eturunagaram"/></div>
  <div class="form-row"><label>Habitation</label><input id="tankHabitation" placeholder="Ellishettypalle"/></div>
  <div class="form-row"><label>Latitude *</label><input id="tankLat" type="number" step="0.000001" placeholder="Right-click map"/></div>
  <div class="form-row"><label>Longitude *</label><input id="tankLng" type="number" step="0.000001" placeholder="Right-click map"/></div>
  <div class="modal-actions">
    <button id="saveTank" class="btn success"><i class="fas fa-save"></i> Save</button>
    <button class="btn" data-close="tankModal"><i class="fas fa-times"></i> Cancel</button>
  </div>
</div>
    </div>
  </div>

  <!-- Valve Modal -->
  <div class="modal" id="valveModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="valveModalTitle">Add Valve</h3>
        <button class="close-x" data-close="valveModal"><i class="fas fa-xmark"></i></button>
      </div>
      <div class="modal-body">
        <div class="form-row">
          <label>Valve ID * (Unique)</label>
          <input id="valveId" placeholder="VALVE-001" maxlength="50"/>
          <div class="error" id="valveIdError"></div>
        </div>
        <div class="form-row"><label>Name *</label><input id="valveName" placeholder="Main Gate Valve"/></div>
        <div class="form-row"><label>Type *</label>
          <select id="valveType">
            <option value="STRAIGHT">Straight</option>
            <option value="ELBOW">Elbow</option>
            <option value="TEE">Tee</option>
          </select>
        </div>
        <div class="form-row"><label>Category *</label>
          <select id="valveCategory">
            <option value="main">Main</option>
            <option value="sub">Sub</option>
          </select>
        </div>
        <div class="form-row" id="parentValveRow" style="display:none">
          <label>Parent Main Valve</label>
          <select id="parentValve"></select>
        </div>
<div class="form-row"><label>Households *</label><input id="valveHouseholds" type="number" placeholder="10"/></div>
<div class="form-row"><label>Flow Rate (L/min) *</label><input id="valveFlowRate" type="number" placeholder="50"/></div>        <div class="form-row"><label>Mandal</label><input id="valveMandal" placeholder="Eturunagaram"/></div>
        <div class="form-row"><label>Habitation</label><input id="valveHabitation" placeholder="Central Area"/></div>
        <div class="form-row"><label>Latitude *</label><input id="valveLat" type="number" step="0.000001" placeholder="Right-click map"/></div>
        <div class="form-row"><label>Longitude *</label><input id="valveLng" type="number" step="0.000001" placeholder="Right-click map"/></div>
        <div class="modal-actions">
          <button id="saveValve" class="btn success"><i class="fas fa-save"></i> Save</button>
          <button class="btn" data-close="valveModal"><i class="fas fa-times"></i> Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Pipeline Modal -->
  <div class="modal" id="pipelineModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="pipelineModalTitle">Pipeline Details</h3>
        <button class="close-x" data-close="pipelineModal"><i class="fas fa-xmark"></i></button>
      </div>
      <div class="modal-body">
        <div class="form-row"><label>Name *</label><input id="pipelineName" placeholder="Main Supply Line"/></div>
        <div class="form-row"><label>Type *</label>
          <select id="pipelineType">
            <option value="PVC">PVC</option>
            <option value="HDPE">HDPE</option>
            <option value="DI">Ductile Iron</option>
          </select>
        </div>
        <div class="form-row"><label>Diameter (mm) *</label><input id="pipelineDiameter" type="number" placeholder="200"/></div>
        <div class="form-row"><label>Capacity (L/min) *</label><input id="pipelineCapacity" type="number" placeholder="800"/></div>
        <div class="form-row"><label>Start point</label><input id="pipelineStart" placeholder="Main Tank"/></div>
        <div class="form-row"><label>End point</label><input id="pipelineEnd" placeholder="Main Valve"/></div>
        <div class="form-row"><label>Notes</label><textarea id="pipelineNotes" placeholder="Optional notes"></textarea></div>
        <div class="modal-actions">
          <button id="savePipeline" class="btn success"><i class="fas fa-save"></i> Save</button>
          <button class="btn danger" id="deleteThisPipeline"><i class="fas fa-trash"></i> Delete</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Manage Modal -->




  <!-- History Modal -->
  <div class="modal" id="historyModal">
    <div class="modal-content modal-content--wide">
      <div class="modal-header">
        <h3 id="historyModalTitle">Device History</h3>
        <button class="close-x" data-close="historyModal"><i class="fas fa-xmark"></i></button>
      </div>
      <div class="modal-body">
        <div class="card card--flush">
          <div class="filter-grid">
            <div class="form-row form-row--compact">
              <label>Start Date</label>
              <input type="date" id="historyStartDate">
            </div>
            <div class="form-row form-row--compact">
              <label>End Date</label>
              <input type="date" id="historyEndDate">
            </div>
            <div class="form-row form-row--compact">
              <label>Time Range (Hours)</label>
              <select id="historyTimeRange">
                <option value="">All Day</option>
                <option value="0-6">12 AM - 6 AM</option>
                <option value="6-12">6 AM - 12 PM</option>
                <option value="12-18">12 PM - 6 PM</option>
                <option value="18-24">6 PM - 12 AM</option>
              </select>
            </div>
            <button class="btn primary btn--compact" id="filterHistoryBtn">
              <i class="fas fa-filter"></i> Filter
            </button>
          </div>
          <div class="card" id="historyDeviceCard" style="display:none">
            <h4><i class="fas fa-satellite-dish"></i> FIELD DEVICE</h4>
            <div class="row"><span class="label">Device ID</span><span class="value" id="historyDeviceId">‚Äî</span></div>
            <div class="row"><span class="label">Last Update</span><span class="value" id="historyDeviceLastUpdate">‚Äî</span></div>
            <div class="row"><span class="label">Distance</span><span class="value" id="historyDeviceDistance">‚Äî</span></div>
            <div class="row"><span class="label">Readings</span><span class="value" id="historyDeviceReadings">‚Äî</span></div>
          </div>
        </div>
        
        <div class="card">
          <div class="flex-between u-mb-12">
            <h4 style="margin: 0;"><i class="fas fa-clock-rotate-left"></i> HISTORICAL DATA</h4>
            <div style="display: flex; gap: 8px;">
              <button class="btn primary btn--compact" id="syncHistoryBtn" title="Fetch and sync all device data to history">
  <i class="fas fa-sync"></i> Sync All Devices
</button>
              <button class="btn success btn--compact" id="exportHistoryBtn">
                <i class="fas fa-download"></i> Export CSV
              </button>
            </div>
          </div>
          <div id="historyContent" class="history-content">
            <div class="empty-state">
              <i class="fas fa-spinner fa-spin"></i>
              <div>Loading history...</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>





  <div class="modal" id="manageModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Manage</h3>
        <button class="close-x" data-close="manageModal"><i class="fas fa-xmark"></i></button>
      </div>
      <div class="modal-body">
        <div class="tab-buttons">
          <button class="btn primary" data-tab="tanks"><i class="fas fa-water"></i> Tanks</button>
          <button class="btn" data-tab="valves"><i class="fas fa-cog"></i> Valves</button>
          <button class="btn" data-tab="pipelines"><i class="fas fa-pipe"></i> Pipelines</button>
          <button class="btn" data-tab="data"><i class="fas fa-database"></i> Data</button>
        </div>
        <div id="manageContent"></div>
      </div>
    </div>
  </div>

  <input id="importFile" type="file" accept=".json" style="display:none"/>
  <div id="toast" class="toast"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
     
<script type="module">
    // Global error handler to prevent page freeze
    window.addEventListener('error', (event) => {
      console.error('üö® Global error caught:', event.error);
      event.preventDefault();
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      console.error('üö® Unhandled promise rejection:', event.reason);
      event.preventDefault();
    });
    
    // Now import modules
    import { Tank, Valve, Pipeline } from './js/models.js';
    import { ImageCache } from './js/imageCache.js';
    import { FirebaseService } from './js/services/firebaseService.js';
    import { HistoryService } from './js/services/historyService.js';
    import { debounce, throttle, updateConnectionStatus as updateConnectionIndicator, showLoading, toast } from './js/utils.js';
    import { POINT_R, LINE_W, CONNECT_THRESH, CLICK_DETECT_RADIUS, DATA_COLLECTION_INTERVAL, DRAW_THROTTLE } from './js/constants.js';

    // ==================== GLOBAL STATE ====================
    let map, canvas, ctx;
    let currentLayer = null;
    let mapLayers = {};
    let tanks = [], valves = [], pipelines = [];
    let mode = 'pipeline';
    let isDrawing = false, currentPipeline = [];
    let hoveredDevice = null;
    let isFirebaseConnected = false;
    let flowCache = null;
    let flowCacheDirty = true;
    let lastDrawTime = 0;
    let dataCollectionInterval = null;
    let supplyDashboardCollapsed = false;
    let analyticsState = null;
    const STREAM_TARGET = 4;
    const scheduleDashboardRender =
      typeof window !== 'undefined' && typeof window.requestIdleCallback === 'function'
        ? (cb) => window.requestIdleCallback(cb, { timeout: 500 })
        : (cb) => {
            if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
              window.requestAnimationFrame(cb);
            } else {
              setTimeout(cb, 16);
            }
          };
    let supplyDashboardUpdateScheduled = false;
    let liveDeviceRecords = {};
    let liveDeviceIndexExact = {};
    let liveDeviceIndexLower = {};
    let currentSidebarDeviceId = null;
    let currentSidebarDeviceType = null;

    function rebuildLiveDeviceIndex(devices = {}) {
      liveDeviceRecords = devices || {};
      liveDeviceIndexExact = {};
      liveDeviceIndexLower = {};
      Object.entries(liveDeviceRecords).forEach(([key, value]) => {
        const entryId = value?.id || key;
        if (!entryId) return;
        const normalizedId = String(entryId);
        const entry = { id: normalizedId, ...value };
        liveDeviceIndexExact[normalizedId] = entry;
        liveDeviceIndexLower[normalizedId.toLowerCase()] = entry;
      });
    }

    function findLiveDeviceTelemetryById(id) {
      if (!id) return null;
      const key = String(id);
      return liveDeviceIndexExact[key] || liveDeviceIndexLower[key.toLowerCase()] || null;
    }

    function resolveDeviceTelemetry(device, overrideId = null) {
      const candidates = [];
      if (overrideId) candidates.push(String(overrideId).toUpperCase().trim());
      if (device?.deviceId) candidates.push(String(device.deviceId).toUpperCase().trim());
      if (device?.id) candidates.push(String(device.id).toUpperCase().trim());
      for (const candidate of candidates) {
        const telemetry = findLiveDeviceTelemetryById(candidate);
        if (telemetry) return telemetry;
      }
      return null;
    }

    function refreshSidebarWithLiveTelemetry() {
      const sidebar = document.getElementById('sidebar');
      if (!sidebar || !sidebar.classList.contains('open')) return;
      if (!currentSidebarDeviceId || !currentSidebarDeviceType) return;
      const sourceList = currentSidebarDeviceType === 'tank' ? tanks : valves;
      const device = sourceList.find((item) => item.id === currentSidebarDeviceId);
      if (device) {
        showDevice(device, currentSidebarDeviceType);
      }
    }

    function updateConnectionStatus(connected) {
      isFirebaseConnected = connected;
      updateConnectionIndicator(connected);
    }









// Error boundary wrapper for calculations
function safeCalculation(fn, fallback, context = 'calculation') {
  try {
    return fn();
  } catch (error) {
    console.error(`‚ùå Error in ${context}:`, error);
    return fallback;
  }
}


// Prevent infinite recursion

// Performance monitoring
function measurePerformance(fn, label) {
  const start = performance.now();
  try {
    const result = fn();
    const duration = performance.now() - start;
    if (duration > 1000) {
      console.warn(`‚ö†Ô∏è Slow operation: ${label} took ${duration.toFixed(2)}ms`);
    }
    return result;
  } catch (error) {
    console.error(`‚ùå Error in ${label}:`, error);
    throw error;
  }
}

    // ==================== HOUSEHOLD SUPPLY CALCULATIONS ====================
// ==================== HOUSEHOLD SUPPLY CALCULATIONS ====================
// Prevent infinite recursion
let calculationInProgress = false;
let lastCalculationResult = null;

function calculateHouseholdStats() {
  // Return cached result if calculation in progress
  if (calculationInProgress) {
    console.warn('‚ö†Ô∏è Calculation already in progress, returning cached data');
    return lastCalculationResult || { 
      stats: { 
        totalHouseholds: 0, 
        servedHouseholds: 0, 
        mainValves: [], 
        totalSupplyFlow: 0, 
        averageSupplyPerHousehold: 0 
      }, 
      regions: {}, 
      valveTree: new Map() 
    };
  }
  
  calculationInProgress = true;
  
  try {
    // Use server-computed analytics if available
    if(analyticsState?.household) {
      const { stats = {}, regions = {}, valveTree = {} } = analyticsState.household;
      const mappedTree = new Map();
      Object.entries(valveTree).forEach(([id, node]) => mappedTree.set(id, node));
      lastCalculationResult = { stats, regions, valveTree: mappedTree };
      return lastCalculationResult;
    }

    const stats = { 
      totalHouseholds: 0, 
      servedHouseholds: 0, 
      mainValves: [],
      totalSupplyFlow: 0,
      averageSupplyPerHousehold: 0
    };

    // Build valve tree structure
    const valveTree = new Map();
    const mainValveIds = [];
    
    // Safety check for valves array
    if (!Array.isArray(valves) || valves.length === 0) {
      lastCalculationResult = { stats, regions: {}, valveTree };
      return lastCalculationResult;
    }
    
    valves.forEach(valve => {
      if (!valve || !valve.id) return; // Skip invalid valves
      
      valveTree.set(valve.id, {
        valve: valve,
        children: [],
        totalHouseholds: valve.households || 0,
        directHouseholds: valve.households || 0,
        servedHouseholds: 0,
        totalFlow: 0
      });
      
      if(valve.category === 'main') {
        mainValveIds.push(valve.id);
      }
    });
    
    // Link children to parents
    valves.forEach(valve => {
      if (!valve || !valve.id) return;
      
      if(valve.category === 'sub' && valve.parentValveId) {
        const parent = valveTree.get(valve.parentValveId);
        const child = valveTree.get(valve.id);
        if(parent && child) {
          parent.children.push(child);
        }
      }
    });
    
    // Calculate direct households for main valves
    mainValveIds.forEach(mainId => {
      const mainNode = valveTree.get(mainId);
      if(!mainNode) return;
      
      const subValvesTotal = mainNode.children.reduce((sum, child) => 
        sum + (child.valve?.households || 0), 0);
      
      mainNode.directHouseholds = Math.max(0, mainNode.totalHouseholds - subValvesTotal);
    });
    
    // Calculate flow for each valve
    function calculateValveFlows() {
      const flow = safeCalculation(() => computeFlow(), { p: {} }, 'computeFlow');
      
      valveTree.forEach(node => {
        if(!node.valve.active) {
          const connectedPipelines = safeCalculation(
            () => findAffectedPipelines(node.valve), 
            [], 
            'findAffectedPipelines'
          );
          
          let totalFlow = 0;
          connectedPipelines.forEach(pipe => {
            if(pipe.currentFlow > 0) {
              totalFlow += pipe.currentFlow;
            }
          });
          
          node.totalFlow = totalFlow;
        } else {
          node.totalFlow = 0;
        }
      });
    }
    
    calculateValveFlows();
    
    // Calculate served households and distribute flow
    function calculateServedHouseholds(mainNode) {
      let served = 0;
      
      if(!mainNode.valve.active) {
        const openSubValves = mainNode.children.filter(c => !c.valve.active);
        
        openSubValves.forEach(child => {
          served += child.valve.households || 0;
          child.servedHouseholds = child.valve.households || 0;
        });
        
        if(mainNode.directHouseholds > 0) {
          served += mainNode.directHouseholds;
        }
        
        if(mainNode.totalFlow > 0 && served > 0) {
          const totalOpenHouseholds = served;
          
          openSubValves.forEach(child => {
            child.totalFlow = (child.valve.households / totalOpenHouseholds) * mainNode.totalFlow;
          });
          
          mainNode.directFlow = (mainNode.directHouseholds / totalOpenHouseholds) * mainNode.totalFlow;
        } else {
          mainNode.directFlow = 0;
        }
      } else {
        served = 0;
        mainNode.children.forEach(child => {
          child.servedHouseholds = 0;
          child.totalFlow = 0;
        });
        mainNode.directFlow = 0;
      }
      
      mainNode.servedHouseholds = served;
      return served;
    }
    
    // Group by region
    const regions = {};
    
    // Process main valves
    mainValveIds.forEach(mainId => {
      const mainNode = valveTree.get(mainId);
      if(!mainNode || !mainNode.valve) return;
      
      const mainValve = mainNode.valve;
      
      calculateServedHouseholds(mainNode);
      
      const mainValveData = {
        valve: mainValve,
        subValves: mainNode.children.map(c => c.valve).filter(Boolean),
        totalHouseholds: mainNode.totalHouseholds,
        directHouseholds: mainNode.directHouseholds,
        servedHouseholds: mainNode.servedHouseholds,
        totalFlow: mainNode.totalFlow,
        directFlow: mainNode.directFlow || 0,
        treeNode: mainNode
      };
      
      stats.mainValves.push(mainValveData);
      
      const regionKey = mainValve.mandal || 'Unknown';
      if(!regions[regionKey]) {
        regions[regionKey] = {
          name: regionKey,
          mainValves: [],
          totalHouseholds: 0,
          servedHouseholds: 0,
          totalFlow: 0
        };
      }
      regions[regionKey].mainValves.push(mainValveData);
    });
    
    // Calculate totals
    stats.mainValves.forEach(mainData => {
      stats.totalHouseholds += mainData.totalHouseholds;
      stats.servedHouseholds += mainData.servedHouseholds;
      stats.totalSupplyFlow += mainData.totalFlow;
    });
    
    // Calculate regional statistics
    Object.values(regions).forEach(region => {
      region.totalHouseholds = region.mainValves.reduce((sum, mv) => sum + mv.totalHouseholds, 0);
      region.servedHouseholds = region.mainValves.reduce((sum, mv) => sum + mv.servedHouseholds, 0);
      region.totalFlow = region.mainValves.reduce((sum, mv) => sum + mv.totalFlow, 0);
    });
    
    stats.averageSupplyPerHousehold = stats.servedHouseholds > 0 ? 
      stats.totalSupplyFlow / stats.servedHouseholds : 0;
    
    lastCalculationResult = { stats, regions, valveTree };
    return lastCalculationResult;
    
  } catch (error) {
    console.error('‚ùå Error in calculateHouseholdStats:', error);
    return lastCalculationResult || { 
      stats: { 
        totalHouseholds: 0, 
        servedHouseholds: 0, 
        mainValves: [], 
        totalSupplyFlow: 0, 
        averageSupplyPerHousehold: 0 
      }, 
      regions: {}, 
      valveTree: new Map() 
    };
  } finally {
    // CRITICAL: Always reset the flag
    calculationInProgress = false;
  }
}





// ==================== TANK ETA CALCULATION ====================
function calculateTankETA(tank) {
  // Use server-computed analytics if available
  const serverEta = analyticsState?.tanks?.[tank.id]?.eta;
  if(serverEta) {
    console.log('üìä Using server-computed ETA for', tank.name);
    return serverEta;
  }
  
  console.log('üîç Calculating ETA for tank:', tank.name, 'Connected valves:', tank.connectedMainValves);
  
  // Check if tank has connected main valves configured
  if (!tank.connectedMainValves || tank.connectedMainValves.length === 0) {
    return {
      status: 'not_configured',
      message: 'No main valves connected to this tank',
      eta: null,
      flowRate: 0,
      details: []
    };
  }
  
  // ‚úÖ USE LIVE DATA GETTER FOR ACCURATE VOLUME
  const liveData = getLiveTankData(tank);
  const currentVolume = liveData.currentVolume; // Already in liters
  const currentWaterLevel = liveData.currentWaterLevel; // Live water level in meters
  
  console.log('üìä Using LIVE volume:', currentVolume, 'L from water level:', currentWaterLevel.toFixed(2), 'm');
  
  // Get ALL connected main valves
  const connectedMainValves = valves.filter(v =>
    tank.connectedMainValves.includes(v.id) && v.category === 'main'
  );
  
  console.log('üìã Found connected main valves:', connectedMainValves.map(v => ({
    name: v.name,
    id: v.id,
    flowRate: v.flowRate,
    active: v.active
  })));
  
  if (connectedMainValves.length === 0) {
    return {
      status: 'not_configured',
      message: 'Connected main valves not found in system',
      eta: null,
      flowRate: 0,
      details: []
    };
  }
  
  // Calculate TOTAL flow from ALL connected main valves
  let totalCurrentFlow = 0;
  let totalPotentialFlow = 0;
  let totalHouseholdsServed = 0;
  let totalHouseholdsCapacity = 0;
  const valveDetails = [];
  
  // Process EACH connected main valve and its hierarchy
  connectedMainValves.forEach(mainValve => {
    console.log('üîß Processing main valve:', mainValve.name, 'Flow rate:', mainValve.flowRate, 'Active:', mainValve.active);
    
    // Get ALL sub-valves for this main valve
    const subValves = valves.filter(v => 
      v.category === 'sub' && v.parentValveId === mainValve.id
    );
    
    console.log('   Sub-valves found:', subValves.length, subValves.map(sv => ({
      name: sv.name, 
      flowRate: sv.flowRate, 
      active: sv.active
    })));
    
    // Calculate flow for this main valve system
    let mainValveCurrentFlow = 0;
    let mainValvePotentialFlow = 0;
    let mainValveHouseholdsServed = 0;
    let mainValveHouseholdsCapacity = mainValve.households || 0;
    
    if (!mainValve.active) {
      // Main valve is OPEN - calculate flow from entire system
      
      // 1. Main valve's own direct flow
      if (mainValve.flowRate > 0) {
        mainValveCurrentFlow += mainValve.flowRate;
        mainValvePotentialFlow += mainValve.flowRate;
        mainValveHouseholdsServed += mainValve.households || 0;
      }
      
      // 2. Add flow from OPEN sub-valves
      const openSubValves = subValves.filter(v => !v.active);
      openSubValves.forEach(subValve => {
        mainValveCurrentFlow += subValve.flowRate || 0;
        mainValvePotentialFlow += subValve.flowRate || 0;
        mainValveHouseholdsServed += subValve.households || 0;
      });
      
      // 3. Add POTENTIAL flow from closed sub-valves
      const closedSubValves = subValves.filter(v => v.active);
      closedSubValves.forEach(subValve => {
        mainValvePotentialFlow += subValve.flowRate || 0;
      });
      
    } else {
      // Main valve is CLOSED - no current flow, but calculate potential
      if (mainValve.flowRate > 0) {
        mainValvePotentialFlow += mainValve.flowRate;
      }
      subValves.forEach(subValve => {
        mainValvePotentialFlow += subValve.flowRate || 0;
      });
    }
    
    // Add this main valve's contribution to totals
    totalCurrentFlow += mainValveCurrentFlow;
    totalPotentialFlow += mainValvePotentialFlow;
    totalHouseholdsServed += mainValveHouseholdsServed;
    totalHouseholdsCapacity += mainValveHouseholdsCapacity;
    
    valveDetails.push({
      id: mainValve.id,
      name: mainValve.name,
      isOpen: !mainValve.active,
      actualFlow: mainValveCurrentFlow,
      potentialFlow: mainValvePotentialFlow,
      openSubValves: subValves.filter(v => !v.active).length,
      totalSubValves: subValves.length,
      households: mainValveHouseholdsCapacity,
      householdsServed: mainValveHouseholdsServed,
      currentFlow: mainValveCurrentFlow,
      maxFlow: mainValvePotentialFlow,
      subValves: subValves.map(sv => ({
        name: sv.name,
        flowRate: sv.flowRate,
        active: sv.active,
        households: sv.households
      }))
    });
  });
  
  console.log('üìä FINAL TOTALS - Current Flow:', totalCurrentFlow, 'Potential Flow:', totalPotentialFlow, 'Households Served:', totalHouseholdsServed);
  
  // Calculate ETAs using ACTUAL total flow
  let currentETA = null;
  let potentialETA = null;
  let currentTimeMinutes = 0;
  let potentialTimeMinutes = 0;
  
  if (totalCurrentFlow > 0) {
    currentTimeMinutes = currentVolume / totalCurrentFlow;
    const currentETATimestamp = Date.now() + (currentTimeMinutes * 60 * 1000);
    currentETA = new Date(currentETATimestamp);
  }
  
  if (totalPotentialFlow > 0) {
    potentialTimeMinutes = currentVolume / totalPotentialFlow;
    const potentialETATimestamp = Date.now() + (potentialTimeMinutes * 60 * 1000);
    potentialETA = new Date(potentialETATimestamp);
  }
  
  // Format time display
  const formatTime = (minutes) => {
    if (minutes === Infinity || isNaN(minutes) || !isFinite(minutes)) return 'Infinite';
    const totalMinutes = Math.max(0, minutes);
    const days = Math.floor(totalMinutes / (60 * 24));
    const remainingHours = Math.floor((totalMinutes % (60 * 24)) / 60);
    const remainingMinutes = Math.floor(totalMinutes % 60);
    
    if (days > 0) {
      return `${days}d ${remainingHours}h ${remainingMinutes}m`;
    } else if (remainingHours > 0) {
      return `${remainingHours}h ${remainingMinutes}m`;
    } else {
      return `${remainingMinutes}m`;
    }
  };
  
  // Determine status based on current flow and time
  let status = 'good';
  let statusColor = '#4caf50';
  let statusMessage = 'Supply is stable';
  
  if (totalCurrentFlow === 0) {
    status = 'no_flow';
    statusColor = '#999';
    statusMessage = 'No water flowing - all valves closed';
  } else if (currentTimeMinutes < 60) { // 1 hour
    status = 'critical';
    statusColor = '#f44336';
    statusMessage = 'CRITICAL: Tank will be empty soon!';
  } else if (currentTimeMinutes < 240) { // 4 hours
    status = 'warning';
    statusColor = '#ff9800';
    statusMessage = 'Warning: Low water level';
  }
  
  console.log('‚è∞ ETA Calculation Complete:', {
    status,
    currentTimeMinutes,
    currentTimeFormatted: formatTime(currentTimeMinutes),
    totalCurrentFlow,
    currentVolume,
    currentWaterLevel
  });
  
  return {
    status,
    statusColor,
    statusMessage,
    currentFlow: totalCurrentFlow,
    potentialFlow: totalPotentialFlow,
    currentVolume: Math.round(currentVolume),
    tankCapacity: liveData.maxCapacity,
    waterLevel: currentWaterLevel,
    currentETA: currentETA,
    currentETAFormatted: currentETA ? currentETA.toLocaleString() : 'N/A',
    currentTimeMinutes: Math.round(currentTimeMinutes * 10) / 10,
    currentTimeFormatted: totalCurrentFlow > 0 ? formatTime(currentTimeMinutes) : 'Infinite',
    potentialETA: potentialETA,
    potentialETAFormatted: potentialETA ? potentialETA.toLocaleString() : 'N/A',
    potentialTimeMinutes: Math.round(potentialTimeMinutes * 10) / 10,
    potentialTimeFormatted: totalPotentialFlow > 0 ? formatTime(potentialTimeMinutes) : 'Infinite',
    connectedMainValves: connectedMainValves.length,
    openMainValves: connectedMainValves.filter(v => !v.active).length,
    totalHouseholdsServed: totalHouseholdsServed,
    totalHouseholdsCapacity: totalHouseholdsCapacity,
    valveDetails: valveDetails,
    calculationDetails: {
      tankHeight: tank.height,
      sensorHeight: tank.sensorHeight,
      currentWaterLevel: currentWaterLevel,
      currentVolume: currentVolume,
      totalCurrentFlow: totalCurrentFlow,
      totalPotentialFlow: totalPotentialFlow,
      connectedValvesCount: connectedMainValves.length,
      usingLiveData: liveData.usingLiveData,
      isDataFresh: liveData.isDataFresh
    }
  };
}








function calculatePipelineCapacity(diameterMM) {
  // Basic formula: Flow capacity in L/min based on pipe diameter
  // Using simplified hydraulic formula: Q = œÄ * (d/2)^2 * v
  // Where d is diameter in meters, v is velocity in m/s (assuming 1.5 m/s typical velocity)
  const diameterM = diameterMM / 1000;
  const crossSectionArea = Math.PI * Math.pow(diameterM / 2, 2);
  const velocity = 1.5; // 1.5 m/s typical water velocity
  const flowRateM3s = crossSectionArea * velocity;
  const flowRateLmin = flowRateM3s * 1000 * 60; // Convert to L/min
  
  return Math.round(flowRateLmin);
}


// Add this event listener after your existing initUI code
const diameterInput = document.getElementById('pipelineDiameter');
if (diameterInput) {
  diameterInput.addEventListener('change', (e) => {
    const diameter = parseFloat(e.target.value);
    if (!isNaN(diameter) && diameter > 0) {
      const capacity = calculatePipelineCapacity(diameter);
      document.getElementById('pipelineCapacity').value = capacity;
    }
  });
}

    function calculateSupplyPerHousehold() {
  // Use server-computed supplies if available
  if(analyticsState?.household?.supplies) {
    return analyticsState.household.supplies;
  }

  const supplies = [];
  
  try {
    const { stats, valveTree } = safeCalculation(
      () => calculateHouseholdStats(),
      { stats: { mainValves: [] }, valveTree: new Map() },
      'calculateHouseholdStats in calculateSupplyPerHousehold'
    );

    // Process each main valve and its children
    stats.mainValves.forEach(mainData => {
      const mainNode = mainData.treeNode;
      
      if(!mainData.valve.active && mainData.totalFlow > 0) {
        // Add supply info for each open sub-valve
        mainData.subValves.forEach(subValve => {
          const subNode = valveTree.get(subValve.id);
          if(!subNode) return;
          
          if(!subValve.active && subValve.households > 0) {
            const avgSupply = subNode.totalFlow > 0 ? 
              subNode.totalFlow / subValve.households : 0;
            
            supplies.push({
              valveId: subValve.id,
              valveName: subValve.name,
              households: subValve.households,
              totalFlow: subNode.totalFlow,
              avgSupply: avgSupply,
              mandal: subValve.mandal,
              habitation: subValve.habitation,
              parentValve: mainData.valve.name,
              type: 'sub'
            });
          }
        });
        
        // Add main valve's direct households if any
        if(mainNode.directHouseholds > 0) {
          const avgSupply = mainNode.directFlow > 0 ? 
            mainNode.directFlow / mainNode.directHouseholds : 0;
          
          supplies.push({
            valveId: mainData.valve.id,
            valveName: `${mainData.valve.name} (Direct)`,
            households: mainNode.directHouseholds,
            totalFlow: mainNode.directFlow,
            avgSupply: avgSupply,
            mandal: mainData.valve.mandal,
            habitation: mainData.valve.habitation,
            parentValve: 'Main Line',
            type: 'main-direct'
          });
        }
      }
    });

    return supplies;
    
  } catch (error) {
    console.error('‚ùå Error in calculateSupplyPerHousehold:', error);
    return [];
  }
}

    // ==================== SUPPLY DASHBOARD ====================
    // ==================== SUPPLY DASHBOARD WITH REGIONAL FILTER ====================
let currentRegionFilter = null; // null means show all regions

function requestSupplyDashboardUpdate() {
  if (supplyDashboardUpdateScheduled) return;
  supplyDashboardUpdateScheduled = true;
  
  scheduleDashboardRender(() => {
    supplyDashboardUpdateScheduled = false;
    try {
      updateSupplyDashboard();
    } catch (error) {
      console.error('‚ùå Supply dashboard render failed:', error);
    }
  });
}

function updateSupplyDashboard() {
  try {
    const dashboardBody = document.getElementById('supplyDashboardBody');
    if (!dashboardBody) {
      console.warn('Supply dashboard body not found');
      return;
    }
    
    const { stats, regions, valveTree } = safeCalculation(
      () => calculateHouseholdStats(),
      { 
        stats: { totalHouseholds: 0, servedHouseholds: 0, mainValves: [], totalSupplyFlow: 0, averageSupplyPerHousehold: 0 }, 
        regions: {}, 
        valveTree: new Map() 
      },
      'calculateHouseholdStats'
    );
    
    const supplies = safeCalculation(
      () => calculateSupplyPerHousehold(),
      [],
      'calculateSupplyPerHousehold'
    );
    
    if (Object.keys(regions).length === 0) {
      dashboardBody.innerHTML = `
        <div style="text-align: center; padding: 20px; color: var(--muted);">
          <i class="fas fa-tachometer-alt" style="font-size: 24px; margin-bottom: 8px;"></i>
          <div>No supply data available</div>
        </div>
      `;
      return;
    }
    
    let html = '';
    
    // Add region filter dropdown
    const regionNames = Object.keys(regions);
    if (regionNames.length > 1) {
      html += `
        <div style="margin-bottom: 12px; padding: 12px; background: #f8f9fa; border-radius: 8px;">
          <label style="font-size: 12px; font-weight: 600; color: var(--muted); display: block; margin-bottom: 6px;">
            <i class="fas fa-filter"></i> FILTER BY REGION
          </label>
          <select id="regionFilterSelect" style="width: 100%; padding: 8px; border: 1px solid var(--line); border-radius: 6px; font-size: 13px;">
            <option value="">All Regions</option>
            ${regionNames.map(name => `
              <option value="${name}" ${currentRegionFilter === name ? 'selected' : ''}>${name}</option>
            `).join('')}
          </select>
        </div>
      `;
    }
    
    // Filter regions based on selection
    const filteredRegions = currentRegionFilter 
      ? { [currentRegionFilter]: regions[currentRegionFilter] }
      : regions;
    
    // Calculate filtered totals
    const filteredStats = {
      totalHouseholds: 0,
      servedHouseholds: 0,
      totalSupplyFlow: 0
    };
    
    Object.values(filteredRegions).forEach(region => {
      filteredStats.totalHouseholds += region.totalHouseholds || 0;
      filteredStats.servedHouseholds += region.servedHouseholds || 0;
      filteredStats.totalSupplyFlow += region.totalFlow || 0;
    });
    
    filteredStats.averageSupplyPerHousehold = filteredStats.servedHouseholds > 0 
      ? filteredStats.totalSupplyFlow / filteredStats.servedHouseholds 
      : 0;
    
    // Add summary section
    html += `
      <div class="supply-summary">
        ${currentRegionFilter ? `
          <div style="background: rgba(255,255,255,0.15); padding: 8px; border-radius: 6px; margin-bottom: 12px; text-align: center;">
            <div style="font-size: 11px; opacity: 0.8;">SHOWING DATA FOR</div>
            <div style="font-size: 14px; font-weight: 700;">${currentRegionFilter}</div>
          </div>
        ` : ''}
        <div class="supply-summary-row">
          <span class="supply-summary-label">Total Households</span>
          <span class="supply-summary-value">${filteredStats.totalHouseholds}</span>
        </div>
        <div class="supply-summary-row">
          <span class="supply-summary-label">Served Households</span>
          <span class="supply-summary-value">${filteredStats.servedHouseholds}</span>
        </div>
        <div class="supply-summary-row">
          <span class="supply-summary-label">Coverage</span>
          <span class="supply-summary-value">${filteredStats.totalHouseholds > 0 ? ((filteredStats.servedHouseholds / filteredStats.totalHouseholds) * 100).toFixed(1) : 0}%</span>
        </div>
        <div class="supply-summary-row">
          <span class="supply-summary-label">Total Flow</span>
          <span class="supply-summary-value">${filteredStats.totalSupplyFlow.toFixed(0)} L/min</span>
        </div>
        <div class="supply-summary-row">
          <span class="supply-summary-label">Avg Supply/HH</span>
          <span class="supply-summary-value">${filteredStats.averageSupplyPerHousehold.toFixed(1)} L/min</span>
        </div>
      </div>
    `;
    
    // Add regions
    Object.values(filteredRegions).forEach(region => {
      if (region.mainValves && region.mainValves.length > 0) {
        html += `
          <div class="supply-region">
            <div class="supply-region-header">
              <div class="supply-region-name">${region.name}</div>
              <div class="supply-region-stats">
                <span>${region.servedHouseholds}/${region.totalHouseholds} HH</span>
                <span>${region.totalFlow.toFixed(0)} L/min</span>
              </div>
            </div>
            <div class="supply-region-body">
        `;
        
        region.mainValves.forEach(mainValveData => {
          const mainValve = mainValveData.valve;
          const mainNode = mainValveData.treeNode;
          
          html += `
            <div class="supply-valve">
              <div class="supply-valve-info">
                <div class="supply-valve-name">${mainValve.name} (Main)</div>
                <div class="supply-valve-meta">
                  Total: ${mainValveData.totalHouseholds} HH 
                  ${mainNode.directHouseholds > 0 ? `‚Ä¢ Direct: ${mainNode.directHouseholds} HH` : ''}
                  ‚Ä¢ Served: ${mainValveData.servedHouseholds}/${mainValveData.totalHouseholds}
                </div>
              </div>
              <div>
                <span class="supply-valve-status ${mainValve.active ? 'closed' : 'open'}">
                  ${mainValve.active ? 'CLOSED' : 'OPEN'}
                </span>
                <div class="supply-valve-flow">${mainValveData.totalFlow.toFixed(0)} L/min</div>
              </div>
            </div>
          `;
          
          if(mainNode.directHouseholds > 0 && !mainValve.active) {
            const directSupply = supplies.find(s => s.valveId === mainValve.id && s.type === 'main-direct');
            const directFlow = mainNode.directFlow || 0;
            const avgSupply = directSupply ? directSupply.avgSupply : 0;
            
            html += `
              <div class="supply-valve" style="margin-left: 12px; background: #f0f7ff;">
                <div class="supply-valve-info">
                  <div class="supply-valve-name">‚Ü≥ Direct Connection</div>
                  <div class="supply-valve-meta">
                    ${mainNode.directHouseholds} HH ‚Ä¢ ${avgSupply.toFixed(2)} L/min/HH
                  </div>
                </div>
                <div>
                  <div class="supply-valve-flow">${directFlow.toFixed(0)} L/min</div>
                </div>
              </div>
            `;
          }
          
          mainValveData.subValves.forEach(subValve => {
            const subNode = valveTree.get(subValve.id);
            const subValveSupply = supplies.find(s => s.valveId === subValve.id);
            const flow = subValveSupply ? subValveSupply.totalFlow : 0;
            const avgSupply = subValveSupply ? subValveSupply.avgSupply : 0;
            
            html += `
              <div class="supply-valve" style="margin-left: 12px;">
                <div class="supply-valve-info">
                  <div class="supply-valve-name">‚Ü≥ ${subValve.name}</div>
                  <div class="supply-valve-meta">
                    ${subValve.households} HH ‚Ä¢ ${avgSupply.toFixed(2)} L/min/HH ‚Ä¢ ${subValve.habitation}
                  </div>
                </div>
                <div>
                  <span class="supply-valve-status ${subValve.active ? 'closed' : 'open'}">
                    ${subValve.active ? 'CLOSED' : 'OPEN'}
                  </span>
                  <div class="supply-valve-flow">${flow.toFixed(0)} L/min</div>
                </div>
              </div>
            `;
          });
        });
        
        html += `</div></div>`;
      }
    });
    
    dashboardBody.innerHTML = html;
    
    // Add event listener for region filter
    const filterSelect = document.getElementById('regionFilterSelect');
    if (filterSelect) {
      filterSelect.addEventListener('change', (e) => {
        currentRegionFilter = e.target.value || null;
        requestSupplyDashboardUpdate();
        toast(currentRegionFilter ? `üìç Filtered: ${currentRegionFilter}` : 'üåç Showing all regions');
      });
    }
    
  } catch (error) {
    console.error('‚ùå Error updating supply dashboard:', error);
    const dashboardBody = document.getElementById('supplyDashboardBody');
    if (dashboardBody) {
      dashboardBody.innerHTML = `
        <div style="text-align: center; padding: 20px; color: var(--danger);">
          <i class="fas fa-exclamation-triangle" style="font-size: 24px; margin-bottom: 8px;"></i>
          <div>Error loading dashboard</div>
        </div>
      `;
    }
  }
}

// Auto-filter dashboard when viewing a device
function autoFilterDashboardByDevice(device) {
  const regionKey = device.mandal || (device.state ? `${device.state}-${device.district}` : null);
  if (regionKey) {
    currentRegionFilter = regionKey;
    requestSupplyDashboardUpdate();
  }
}

    function toggleSupplyDashboard() {
      const dashboard = document.getElementById('supplyDashboard');
      const body = document.getElementById('supplyDashboardBody');
      const toggleBtn = document.getElementById('toggleSupplyDashboard');
      
      if (supplyDashboardCollapsed) {
        body.style.display = 'block';
        toggleBtn.innerHTML = '<i class="fas fa-chevron-down"></i>';
        supplyDashboardCollapsed = false;
      } else {
        body.style.display = 'none';
        toggleBtn.innerHTML = '<i class="fas fa-chevron-up"></i>';
        supplyDashboardCollapsed = true;
      }
    }

    // ==================== INITIALIZATION ====================
    let isInitialized = false;
    let loadedCount = 0;
    
    async function initializeWaterApp() {



      
      if(isInitialized) return;
      isInitialized = true;
      
      showLoading(true);
      updateConnectionStatus(false);
      
      try {
        await ImageCache.preload();
        
        // Wait for Leaflet to be fully loaded
        if(typeof L === 'undefined') {
          console.error('Leaflet not loaded yet');
          setTimeout(initializeWaterApp, 100);
          return;
        }
        
        initMap();
        initCanvas();
        initUI();
        
        const checkAllLoaded = () => {
          loadedCount++;
          if(loadedCount >= STREAM_TARGET) {
            updateConnectionStatus(true);
            showLoading(false);
            if(tanks.length === 0 && valves.length === 0 && pipelines.length === 0) {
              setTimeout(initializeDummyData, 500);
            }
          }
        };


        // Increase debounce times to prevent rapid recalculations
const debouncedDraw = debounce(requestDrawCanvas, 1000);
const debouncedDashboard = debounce(requestSupplyDashboardUpdate, 2000);

// Add update batching
let updateBatch = { tanks: false, valves: false, pipelines: false, analytics: false };
let batchTimeout = null;

function processBatchedUpdates() {
  if (updateBatch.tanks || updateBatch.valves || updateBatch.pipelines || updateBatch.analytics) {
    flowCacheDirty = true;
    debouncedDraw();
    debouncedDashboard();
    updateBatch = { tanks: false, valves: false, pipelines: false, analytics: false };
  }
}

FirebaseService.listenToTanks((loadedTanks) => {
  console.log(`üì¶ Loaded ${loadedTanks.length} tanks`);
  tanks = loadedTanks;
  flowCacheDirty = true;
  updateBatch.tanks = true;
  
  clearTimeout(batchTimeout);
  batchTimeout = setTimeout(processBatchedUpdates, 500);
})

FirebaseService.listenToValves((loadedValves) => {
  console.log(`üì¶ Loaded ${loadedValves.length} valves`);
  valves = loadedValves;
  flowCacheDirty = true;
  updateBatch.valves = true;
  
  clearTimeout(batchTimeout);
  batchTimeout = setTimeout(processBatchedUpdates, 500);
});

FirebaseService.listenToPipelines((loadedPipelines) => {
  console.log(`üì¶ Loaded ${loadedPipelines.length} pipelines`);
  pipelines = loadedPipelines;
  flowCacheDirty = true;
  updateBatch.pipelines = true;
  
  clearTimeout(batchTimeout);
  batchTimeout = setTimeout(processBatchedUpdates, 500);
});

FirebaseService.listenToAnalytics((analytics) => {
  console.log('üìä Analytics updated');
  analyticsState = analytics;
  flowCacheDirty = true;
  updateBatch.analytics = true;
  
  clearTimeout(batchTimeout);
  batchTimeout = setTimeout(processBatchedUpdates, 500);
});

        FirebaseService.listenToDevices(async (devices) => {
          rebuildLiveDeviceIndex(devices);
          if(loadedCount < STREAM_TARGET) checkAllLoaded();
          refreshSidebarWithLiveTelemetry();
          
          // Sync all device readings to history (automatic sync on data update)
          if (FirebaseService.lastDeviceRawData) {
            const skipPaths = ['tanks', 'valves', 'pipelines', 'analytics', 'ultrasonic', 'history'];
            const rawData = FirebaseService.lastDeviceRawData;
            
            // Process root-level device nodes
            for (const deviceId of Object.keys(rawData)) {
              if (skipPaths.includes(deviceId)) continue;
              
              const deviceNode = rawData[deviceId];
              if (!deviceNode || typeof deviceNode !== 'object') continue;
              
              // Extract all readings from this device
              const allReadings = FirebaseService.extractAllReadings(deviceNode);
              
              if (allReadings.length > 0) {
                // Find which tank is linked to this device
                const linkedTank = tanks.find(t => t.deviceId && t.deviceId.toUpperCase() === deviceId.toUpperCase());
                if (linkedTank) {
                  // Sync all readings to history with tank for calculations
                  await HistoryService.syncDeviceReadingsToHistory(linkedTank.id, 'tanks', allReadings, linkedTank);
                }
              }
            }
            
            // Also check /ultrasonic path
            if (rawData.ultrasonic && typeof rawData.ultrasonic === 'object') {
              for (const deviceId of Object.keys(rawData.ultrasonic)) {
                const deviceNode = rawData.ultrasonic[deviceId];
                const allReadings = FirebaseService.extractAllReadings(deviceNode);
                
                if (allReadings.length > 0) {
                  const linkedTank = tanks.find(t => t.deviceId && t.deviceId.toUpperCase() === deviceId.toUpperCase());
                  if (linkedTank) {
                    await HistoryService.syncDeviceReadingsToHistory(linkedTank.id, 'tanks', allReadings, linkedTank);
                  }
                }
              }
            }
          }
          
          // Update tanks with real water levels from devices
          tanks.forEach(tank => {
            if (tank.deviceId) {
              const telemetry = resolveDeviceTelemetry(tank);
              if (telemetry && telemetry.distance !== undefined && telemetry.distance !== null) {
                const newWaterLevel = tank.calculateWaterLevelFromDistance(telemetry.distance);
                if (Math.abs(tank.waterLevel - newWaterLevel) > 0.01) {
                  tank.setWaterLevel(newWaterLevel);
                  flowCacheDirty = true;
                }
              }
            }
          });
          if (flowCacheDirty) {
            requestDrawCanvas();
            requestSupplyDashboardUpdate();
          }
        });
        
        setTimeout(() => {
          if(loadedCount < STREAM_TARGET) {
            console.warn('Firebase loading timeout');
            updateConnectionStatus(false);
            showLoading(false);
          }
        }, 5000);
        

        // Automatically sync all device data to history after initial load
setTimeout(() => {
  // Run sync in background without blocking UI
  if (typeof requestIdleCallback !== 'undefined') {
    requestIdleCallback(async () => {
      console.log('üîÑ Auto-syncing device data to history (background)...');
      try {
        // Fetch all device data directly from Firebase
        const allDeviceData = await FirebaseService.fetchAllDeviceData();
        
        if (Object.keys(allDeviceData).length === 0) {
          console.log('üî≠ No device data found for auto-sync');
          return;
        }
        
        const skipPaths = ['tanks', 'valves', 'pipelines', 'analytics', 'ultrasonic', 'history'];
        let totalSynced = 0;
        
        // Get all device IDs to process
        const deviceIds = Object.keys(allDeviceData).filter(id => !skipPaths.includes(id));
        
        // Process in chunks to avoid blocking
        for (let i = 0; i < deviceIds.length; i++) {
          const deviceId = deviceIds[i];
          const deviceNode = allDeviceData[deviceId];
          
          if (!deviceNode || typeof deviceNode !== 'object') continue;
          
          // Give UI time to breathe every 3 devices
          if (i > 0 && i % 3 === 0) {
            await new Promise(resolve => setTimeout(resolve, 200));
          }
          
          // Extract all readings from this device
          const allReadings = FirebaseService.extractAllReadings(deviceNode);
          
          if (allReadings.length > 0) {
            // Find which tank is linked to this device
            const linkedTank = tanks.find(t => t.deviceId && t.deviceId.toUpperCase() === deviceId.toUpperCase());
            
            if (linkedTank) {
              console.log(`üìÑ Syncing ${allReadings.length} readings for ${deviceId} ‚Üí tank ${linkedTank.id} (background)`);
              // Sync with tank object for calculations
              await HistoryService.syncDeviceReadingsToHistory(linkedTank.id, 'tanks', allReadings, linkedTank);
              totalSynced += allReadings.length;
            }
          }
        }
        
        if (totalSynced > 0) {
          console.log(`‚úÖ Background sync complete! Synced ${totalSynced} readings.`);
        }
      } catch (error) {
        console.error('‚ùå Error in background sync:', error);
      }
    }, { timeout: 15000 });
  } else {
    // Fallback for browsers without requestIdleCallback
    setTimeout(async () => {
      console.log('üîÑ Auto-syncing device data to history (deferred)...');
      try {
        const allDeviceData = await FirebaseService.fetchAllDeviceData();
        if (Object.keys(allDeviceData).length === 0) return;
        
        const skipPaths = ['tanks', 'valves', 'pipelines', 'analytics', 'ultrasonic', 'history'];
        const deviceIds = Object.keys(allDeviceData).filter(id => !skipPaths.includes(id));
        
        for (const deviceId of deviceIds) {
          const deviceNode = allDeviceData[deviceId];
          if (!deviceNode || typeof deviceNode !== 'object') continue;
          
          const allReadings = FirebaseService.extractAllReadings(deviceNode);
          if (allReadings.length > 0) {
            const linkedTank = tanks.find(t => t.deviceId && t.deviceId.toUpperCase() === deviceId.toUpperCase());
            if (linkedTank) {
              await HistoryService.syncDeviceReadingsToHistory(linkedTank.id, 'tanks', allReadings, linkedTank);
            }
          }
        }
        console.log('‚úÖ Deferred sync complete');
      } catch (error) {
        console.error('‚ùå Error in deferred sync:', error);
      }
    }, 8000);
  }
}, 5000); // Increased delay to 5 seconds
        
      } catch(error) {
        console.error('Initialization error:', error);
        showLoading(false);
        toast('‚ö†Ô∏è Initialization error');
      }
    }

    async function initializeDummyData() {
      toast('üì¶ Creating sample data...');
      
      // Create multiple tanks in different regions
      const dummyTanks = [
        {
          id: 'TANK-MAIN-001',
          name: 'Main Distribution Tank',
          lat: 17.9689,
          lng: 79.5941,
          type: 'OHSR',
          capacity: 50000,
          waterLevel: 8.5,
          state: 'Telangana',
          district: 'Mulugu',
          mandal: 'Eturunagaram',
          habitation: 'Central Area'
        },
        {
          id: 'TANK-SEC-001',
          name: 'Secondary Tank - Zone B',
          lat: 17.9750,
          lng: 79.6000,
          type: 'GSR',
          capacity: 30000,
          waterLevel: 7.2,
          state: 'Telangana',
          district: 'Mulugu',
          mandal: 'Venkatapur',
          habitation: 'Zone B Central'
        }
      ];
      
      for(const tankData of dummyTanks) {
        const tank = new Tank(tankData);
        await FirebaseService.saveTank(tank);
      }
      
      // Create main valves for different regions
      const mainValves = [
        {
          id: 'VALVE-MAIN-001',
          name: 'Main Gate Valve - Eturunagaram',
          lat: 17.9700,
          lng: 79.5950,
          type: 'STRAIGHT',
          category: 'main',
          households: 40,
          mandal: 'Eturunagaram',
          habitation: 'Distribution Zone'
        },
        {
          id: 'VALVE-MAIN-002',
          name: 'Main Gate Valve - Venkatapur',
          lat: 17.9760,
          lng: 79.6010,
          type: 'STRAIGHT',
          category: 'main',
          households: 35,
          mandal: 'Venkatapur',
          habitation: 'Distribution Zone'
        }
      ];
      
      for(const valveData of mainValves) {
        const valve = new Valve(valveData);
        await FirebaseService.saveValve(valve);
      }
      
      // Create sub-valves for different regions
      const subValves = [
        {id: 'VALVE-SUB-001', name: 'Sub Valve - Zone A', lat: 17.9710, lng: 79.5960, habitation: 'Zone A', mandal: 'Eturunagaram', parentValveId: 'VALVE-MAIN-001', households: 12},
        {id: 'VALVE-SUB-002', name: 'Sub Valve - Zone B', lat: 17.9715, lng: 79.5965, habitation: 'Zone B', mandal: 'Eturunagaram', parentValveId: 'VALVE-MAIN-001', households: 14},
        {id: 'VALVE-SUB-003', name: 'Sub Valve - Zone C', lat: 17.9720, lng: 79.5970, habitation: 'Zone C', mandal: 'Eturunagaram', parentValveId: 'VALVE-MAIN-001', households: 14},
        {id: 'VALVE-SUB-004', name: 'Sub Valve - North Area', lat: 17.9770, lng: 79.6020, habitation: 'North Area', mandal: 'Venkatapur', parentValveId: 'VALVE-MAIN-002', households: 18},
        {id: 'VALVE-SUB-005', name: 'Sub Valve - South Area', lat: 17.9755, lng: 79.6005, habitation: 'South Area', mandal: 'Venkatapur', parentValveId: 'VALVE-MAIN-002', households: 17}
      ];
      
      for(const sv of subValves) {
        await FirebaseService.saveValve(new Valve({
          ...sv,
          type: 'STRAIGHT',
          category: 'sub'
        }));
      }
      
      // Create pipelines connecting tanks to valves
      const pipeline1 = new Pipeline({
        id: 'PIPE-MAIN-001',
        name: 'Main Supply Line - Eturunagaram',
        type: 'PVC',
        diameter: 200,
        capacity: 800,
        startPoint: 'Main Tank',
        endPoint: 'Main Valve',
        points: [
          {lat: 17.9689, lng: 79.5941},
          {lat: 17.9695, lng: 79.5945},
          {lat: 17.9700, lng: 79.5950}
        ]
      });
      await FirebaseService.savePipeline(pipeline1);
      
      const pipeline2 = new Pipeline({
        id: 'PIPE-DIST-001',
        name: 'Distribution Line - Zone A',
        type: 'PVC',
        diameter: 150,
        capacity: 500,
        startPoint: 'Main Valve',
        endPoint: 'Zone A',
        points: [
          {lat: 17.9700, lng: 79.5950},
          {lat: 17.9705, lng: 79.5955},
          {lat: 17.9710, lng: 79.5960}
        ]
      });
      await FirebaseService.savePipeline(pipeline2);
      
      const pipeline3 = new Pipeline({
        id: 'PIPE-MAIN-002',
        name: 'Main Supply Line - Venkatapur',
        type: 'HDPE',
        diameter: 180,
        capacity: 700,
        startPoint: 'Secondary Tank',
        endPoint: 'Venkatapur Main Valve',
        points: [
          {lat: 17.9750, lng: 79.6000},
          {lat: 17.9755, lng: 79.6005},
          {lat: 17.9760, lng: 79.6010}
        ]
      });
      await FirebaseService.savePipeline(pipeline3);
      
      toast('‚úì Sample data created!');
    }

    document.addEventListener('DOMContentLoaded', initializeWaterApp);

    function initMap() {
      try {
        map = L.map('map', {
          zoomControl: false,
          minZoom: 2,
          maxZoom: 19,
          preferCanvas: true,
          zoomAnimation: true,
          fadeAnimation: true
        }).setView([17.9689, 79.5941], 13);

        // Define map layers
        // Define map layers with multiple backup options
      // Define map layers - Best quality options
      mapLayers = {
        street: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '¬© OpenStreetMap'
        }),
        
        satellite: L.tileLayer('http://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
          maxZoom: 20,
          subdomains: ['0','1','2','3'],
          attribution: '¬© Google'
        }),
        
        dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
          maxZoom: 19,
          subdomains: 'abcd',
          attribution: '¬© CARTO'
        })
      };

        // Add default layer with error handling
        currentLayer = mapLayers.street;
        currentLayer.addTo(map);
        
        // Add error handler for tile loading
        currentLayer.on('tileerror', function(error) {
          console.warn('Tile loading error:', error);
        });

        const debouncedDraw = debounce(requestDrawCanvas, 100);
        map.on('move', debouncedDraw);
        map.on('zoom', debouncedDraw);
        map.on('moveend', requestDrawCanvas);
        map.on('zoomend', requestDrawCanvas);
        map.on('contextmenu', onMapRightClick);
        map.on('click', onMapClick);
        
        console.log('Map initialized successfully');
      } catch(error) {
        console.error('Error initializing map:', error);
        toast('‚ö†Ô∏è Map initialization failed');
      }
    }



    function switchMapLayer(layerName) {
      if(!mapLayers[layerName]) {
        console.error('Layer not available:', layerName);
        toast('‚ö†Ô∏è Map layer not available');
        return;
      }
      
      if(currentLayer) {
        try {
          map.removeLayer(currentLayer);
        } catch(e) {
          console.error('Error removing layer:', e);
        }
      }
      
      currentLayer = mapLayers[layerName];
      
      try {
        currentLayer.addTo(map);
      } catch(e) {
        console.error('Error adding layer:', e);
        toast('‚ö†Ô∏è Failed to load map layer');
        return;
      }
      
      document.querySelectorAll('.layer').forEach(btn => btn.classList.remove('active'));
      document.getElementById(`layer${layerName.charAt(0).toUpperCase() + layerName.slice(1)}`).classList.add('active');
      
      toast(`‚úì ${layerName.charAt(0).toUpperCase() + layerName.slice(1)} view`);
      requestDrawCanvas();
    }

    function initCanvas() {
      canvas = document.getElementById('canvas');
      ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
      resizeCanvas();
      window.addEventListener('resize', debounce(resizeCanvas, 250));

      canvas.addEventListener('mousedown', handleCanvasMouseDown);
      canvas.addEventListener('mousemove', throttle(handleCanvasMouseMove, 16));
      canvas.addEventListener('mouseup', handleCanvasMouseUp);
      canvas.addEventListener('mouseleave', handleCanvasMouseUp);
    }

    function resizeCanvas() {
      const rect = map.getContainer().getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      requestDrawCanvas();
    }

    function initUI() {
      // Tool buttons
      bindBtn('toolPipeline', () => setMode('pipeline'));
      bindBtn('toolTank', () => setMode('tank'));
      bindBtn('toolValve', () => setMode('valve'));
      bindBtn('toolErase', () => setMode('erase'));
      bindBtn('toolManage', openManage);
      bindBtn('toolImport', () => {
        const importFile = document.getElementById('importFile');
        if(importFile) importFile.click();
      });
      bindBtn('toolClear', clearAll);
      bindBtn('layerStreet', () => {
        if(!map || !mapLayers.street) {
          toast('‚ö†Ô∏è Map not ready yet');
          return;
        }
        switchMapLayer('street');
      });
      
      bindBtn('layerSatellite', () => {
        if(!map || !mapLayers.satellite) {
          toast('‚ö†Ô∏è Map not ready yet');
          return;
        }
        switchMapLayer('satellite');
      });
      
      bindBtn('layerDark', () => {
        if(!map || !mapLayers.dark) {
          toast('‚ö†Ô∏è Map not ready yet');
          return;
        }
        switchMapLayer('dark');
      });
      bindBtn('zoomIn', () => map.zoomIn());
      bindBtn('zoomOut', () => map.zoomOut());
      bindBtn('closeSidebar', closeSidebar);
      bindBtn('toggleSupplyDashboard', toggleSupplyDashboard);

      // Modal close buttons
      document.querySelectorAll('[data-close]').forEach(btn => {
        btn.addEventListener('click', () => closeModal(btn.getAttribute('data-close')));
      });
 
      
      // Save buttons
      bindBtn('saveTank', onSaveTank);


      


     // Tank shape toggle
const tankShape = document.getElementById('tankShape');
if(tankShape) {
  tankShape.addEventListener('change', (e) => {
    const cylinderDiv = document.getElementById('cylinderDimensions');
    const cuboidDiv = document.getElementById('cuboidDimensions');
    const isCylinder = e.target.value === 'cylinder';
    
    if(cylinderDiv) cylinderDiv.style.display = isCylinder ? 'block' : 'none';
    if(cuboidDiv) cuboidDiv.style.display = isCylinder ? 'none' : 'block';
  });
}

// Auto-calculate capacity
bindBtn('calculateCapacity', () => {
  const shape = val('tankShape');
  let capacity = 0;
  
  if(shape === 'cylinder') {
    const diameter = parseFloat(val('tankDiameter'));
    const height = parseFloat(val('tankHeight'));
    if(!isNaN(diameter) && !isNaN(height)) {
      const radius = diameter / 2;
      capacity = Math.PI * Math.pow(radius, 2) * height * 1000; // m¬≥ to liters
    }
  } else if(shape === 'cuboid') {
    const length = parseFloat(val('tankLength'));
    const breadth = parseFloat(val('tankBreadth'));
    const height = parseFloat(val('tankHeightCuboid'));
    if(!isNaN(length) && !isNaN(breadth) && !isNaN(height)) {
      capacity = length * breadth * height * 1000; // m¬≥ to liters
    }
  }
  
  if(capacity > 0) {
    setValue('tankCapacity', Math.round(capacity));
    toast(`‚úì Capacity calculated: ${Math.round(capacity).toLocaleString()} L`);
  } else {
    toast('‚ö†Ô∏è Enter valid dimensions');
  }
});







      bindBtn('saveValve', onSaveValve);
      bindBtn('savePipeline', onSavePipeline);

      // Pipeline delete from modal
      const deletePipelineBtn = document.getElementById('deleteThisPipeline');
      if(deletePipelineBtn) {
        deletePipelineBtn.addEventListener('click', () => {
          const pipeId = document.getElementById('pipelineModal').getAttribute('data-pipe-id');
          if(pipeId) deletePipeline(pipeId);
        });
      }

      // Manage modal tabs
      const manageModal = document.getElementById('manageModal');
      if(manageModal) {
        manageModal.addEventListener('click', (e) => {
          const tab = e.target.closest('[data-tab]');
          if (tab) {
            document.querySelectorAll('#manageModal [data-tab]').forEach(b => b.classList.remove('primary'));
            tab.classList.add('primary');
            renderManage(tab.getAttribute('data-tab'));
          }
        });
      }

      // Import file
      const importFile = document.getElementById('importFile');
      if(importFile) {
        importFile.addEventListener('change', importData);
      }
      
      // Valve category change
      const valveCategory = document.getElementById('valveCategory');
      if(valveCategory) {
        valveCategory.addEventListener('change', (e) => {
          const parentRow = document.getElementById('parentValveRow');
          if(parentRow) {
            if(e.target.value === 'sub') {
              parentRow.style.display = 'block';
              updateParentValveList();
            } else {
              parentRow.style.display = 'none';
            }
          }
        });
      }

      // Search functionality
      const searchInput = document.getElementById('searchInput');
      const searchBtn = document.getElementById('searchBtn');
      
      if(searchInput) {
        searchInput.addEventListener('input', debounce(onSearchInput, 400));
        searchInput.addEventListener('keydown', (e) => {
          if(e.key === 'Enter') { e.preventDefault(); executeSearch(); }
          if(e.key === 'Escape') { hideSuggestions(); }
        });
      }
      if(searchBtn) searchBtn.addEventListener('click', executeSearch);
      
      // History modal
      bindBtn('filterHistoryBtn', loadHistory);
      bindBtn('exportHistoryBtn', exportCurrentHistory);
      // Click outside to close suggestions
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.search')) hideSuggestions();
      });

      updateToolbar();
    }

    function updateParentValveList() {
      const select = document.getElementById('parentValve');
      const mainValves = valves.filter(v => v.category === 'main');
      select.innerHTML = '<option value="">None</option>';
      mainValves.forEach(valve => {
        const option = document.createElement('option');
        option.value = valve.id;
        option.textContent = `${valve.name} (${valve.id})`;
        select.appendChild(option);
      });
    }



   function populateMainValvesList(selectedValves = []) {
  const container = document.getElementById('mainValvesList');
  const mainValves = valves.filter(v => v.category === 'main');
  
  if (mainValves.length === 0) {
    container.innerHTML = `
      <div style="text-align: center; color: var(--muted); padding: 20px;">
        <i class="fas fa-exclamation-circle"></i> No main valves available<br>
        <small>Create main valves first before connecting them to tanks</small>
      </div>
    `;
    return;
  }
  
  // Currently selected valves display
  const selectedValvesDisplay = selectedValves.map(valveId => {
    const valve = mainValves.find(v => v.id === valveId);
    if(!valve) return '';
    return `
      <div style="display: flex; justify-content: space-between; align-items: center; 
                  padding: 10px; background: #e8f5e9; border: 1px solid #4caf50; 
                  border-radius: 8px; margin-bottom: 8px;">
        <div style="flex: 1;">
          <div style="font-weight: 700; font-size: 13px;">${valve.name}</div>
          <div style="font-size: 11px; color: #666;">
            ${valve.id} ‚Ä¢ ${valve.households} HH ‚Ä¢ ${valve.mandal}
          </div>
        </div>
        <button class="btn danger" onclick="removeMainValve('${valveId}')" 
                style="margin: 0; padding: 6px 12px; font-size: 11px;">
          <i class="fas fa-times"></i> Remove
        </button>
      </div>
    `;
  }).join('');
  
  // Available valves dropdown (excluding already selected)
  const availableValves = mainValves.filter(v => !selectedValves.includes(v.id));
  const dropdownOptions = availableValves.map(v => 
    `<option value="${v.id}">${v.name} (${v.id}) - ${v.households} HH - ${v.mandal}</option>`
  ).join('');
  
  container.innerHTML = `
    <div style="margin-bottom: 16px;">
      <div style="font-weight: 600; font-size: 12px; color: var(--muted); margin-bottom: 8px;">
        CONNECTED MAIN VALVES (${selectedValves.length})
      </div>
      <div id="selectedValvesList">
        ${selectedValves.length > 0 ? selectedValvesDisplay : '<div style="text-align: center; padding: 20px; color: var(--muted); font-size: 12px;">No valves connected yet</div>'}
      </div>
    </div>
    
    <div style="border-top: 2px dashed var(--line); padding-top: 16px;">
      <div style="font-weight: 600; font-size: 12px; color: var(--muted); margin-bottom: 8px;">
        ADD MAIN VALVE
      </div>
      ${availableValves.length > 0 ? `
        <div style="display: flex; gap: 8px;">
          <select id="valveToAdd" style="flex: 1; padding: 10px; border: 1px solid var(--line); 
                                          border-radius: 8px; font-size: 13px;">
            <option value="">-- Select a valve to add --</option>
            ${dropdownOptions}
          </select>
          <button class="btn success" onclick="addMainValve()" 
                  style="margin: 0; padding: 10px 16px; white-space: nowrap;">
            <i class="fas fa-plus"></i> Add
          </button>
        </div>
        
        <div style="margin-top: 12px;">
          <input type="text" id="valveSearchInput" 
                 placeholder="üîç Search valves by name, ID, or location..." 
                 style="width: 100%; padding: 10px; border: 1px solid var(--line); 
                        border-radius: 8px; font-size: 13px;"/>
        </div>
      ` : `
        <div style="text-align: center; padding: 20px; color: var(--success); font-size: 12px;">
          ‚úÖ All main valves are connected!
        </div>
      `}
    </div>
  `;
  
  // Store selected valves in a global for easy access
  window.currentSelectedValves = [...selectedValves];
  
  // Add search functionality
  const searchInput = document.getElementById('valveSearchInput');
  if(searchInput) {
    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase();
      const dropdown = document.getElementById('valveToAdd');
      const options = dropdown.querySelectorAll('option');
      
      options.forEach((option, idx) => {
        if(idx === 0) return; // Skip placeholder
        const text = option.textContent.toLowerCase();
        option.style.display = text.includes(query) ? 'block' : 'none';
      });
    });
  }
}

// Global functions for valve management (Place these OUTSIDE of populateMainValvesList)
window.addMainValve = function() {
  const dropdown = document.getElementById('valveToAdd');
  const valveId = dropdown.value;
  
  if(!valveId) {
    toast('‚ö†Ô∏è Please select a valve');
    return;
  }
  
  if(!window.currentSelectedValves.includes(valveId)) {
    window.currentSelectedValves.push(valveId);
    populateMainValvesList(window.currentSelectedValves);
    toast('‚úÖ Valve added');
  } else {
    toast('‚ö†Ô∏è Valve already connected');
  }
};

window.removeMainValve = function(valveId) {
  window.currentSelectedValves = window.currentSelectedValves.filter(id => id !== valveId);
  populateMainValvesList(window.currentSelectedValves);
  toast('‚úÖ Valve removed');
};

    function startDataCollection() {
  console.log('‚è∏Ô∏è Client-side data simulator disabled; using server analytics and real device data.');
  // DISABLED: All data collection now handled by server analytics and real devices
  return;
}

    // ==================== MODE CONTROL ====================
    function setMode(m) {
      mode = m;
      updateToolbar();
      if(m === 'pipeline') {
        canvas.classList.add('active');
        canvas.classList.remove('drawing');
        map.dragging.disable();
        map.scrollWheelZoom.disable();
        toast('‚úì Pipeline mode: Click and drag to draw');
      } else if(m === 'erase') {
        canvas.classList.add('active');
        canvas.classList.remove('drawing');
        map.dragging.disable();
        map.scrollWheelZoom.disable();
        toast('‚úì Erase mode: Click pipeline segments');
      } else {
        canvas.classList.remove('active', 'drawing');
        map.dragging.enable();
        map.scrollWheelZoom.enable();
        if(m === 'tank') { toast('‚úì Tank mode: Click map to place tank'); }
        else if(m === 'valve') { toast('‚úì Valve mode: Click pipeline to add valve'); }
      }
    }

    function updateToolbar() {
      setActive('toolPipeline', mode === 'pipeline');
      setActive('toolTank', mode === 'tank');
      setActive('toolValve', mode === 'valve');
      setActive('toolErase', mode === 'erase');
    }

    // ==================== HOVER TOOLTIPS ====================
    function showHoverTooltip(content, x, y) {
      const tooltip = document.getElementById('hoverTooltip');
      tooltip.innerHTML = content;
      tooltip.style.left = `${x + 10}px`;
      tooltip.style.top = `${y + 10}px`;
      tooltip.classList.add('active');
    }

    function hideHoverTooltip() {
      const tooltip = document.getElementById('hoverTooltip');
      tooltip.classList.remove('active');
    }

    function createTooltipContent(device, type) {
      const now = new Date();
      const timeStr = now.toLocaleTimeString('en-IN', {hour: '2-digit', minute: '2-digit'});
      
      if (type === 'tank') {
        const info = device.info();
        const currentVolume = device.calculateCurrentVolume().toFixed(0);
        const maxCapacity = device.calculateMaxCapacity().toFixed(0);
        const fillPercentage = ((parseFloat(currentVolume) / parseFloat(maxCapacity)) * 100).toFixed(1);
        
        return `
          <div class="tooltip-title">
            <i class="fas fa-water" style="color: #03a9f4;"></i> 
            ${device.name}
            <span class="status-indicator ${device.status === 'active' ? 'status-active' : 'status-inactive'}"></span>
            <span class="live-badge">LIVE</span>
          </div>
          
          <div style="font-size: 10px; color: rgba(255,255,255,0.6); margin-bottom: 8px;">
            Last updated: ${timeStr}
          </div>
          
          <div class="tooltip-section">
            <div class="tooltip-section-title">üìä Storage Status</div>
            <div class="tooltip-row">
              <span class="tooltip-label">Type:</span>
              <span class="tooltip-value">${info.type} (${device.shape === 'cylinder' ? 'Cylinder' : 'Cuboid'})</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Current Volume:</span>
              <span class="tooltip-value" style="color: #03a9f4;">${parseInt(currentVolume).toLocaleString()} L</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Max Capacity:</span>
              <span class="tooltip-value">${parseInt(maxCapacity).toLocaleString()} L</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Fill Level:</span>
              <span class="tooltip-value" style="color: ${fillPercentage > 70 ? '#4caf50' : fillPercentage > 30 ? '#ff9800' : '#f44336'};">
                ${fillPercentage}%
              </span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Water Level:</span>
              <span class="tooltip-value">${info.waterLevel}</span>
            </div>
          </div>
          
          <div class="tooltip-section">
            <div class="tooltip-section-title">‚ö° Live Metrics</div>
            <div class="tooltip-row">
              <span class="tooltip-label">Pressure:</span>
              <span class="tooltip-value" style="color: #ff9800;">${info.pressure}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Flow Rate:</span>
              <span class="tooltip-value" style="color: #2196f3;">${info.flowRate}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">pH Level:</span>
              <span class="tooltip-value">${info.pH}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Temperature:</span>
              <span class="tooltip-value">${info.temperature}</span>
            </div>
          </div>
          
          <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 10px; color: rgba(255,255,255,0.6); text-align: center;">
            Click for detailed analysis
          </div>
        `;
      } else if (type === 'valve') {
        const info = device.info();
        const supplies = calculateSupplyPerHousehold();
        const supplyInfo = supplies.find(s => s.valveId === device.id);
        const analyticsValve = analyticsState?.valves?.[device.id] || null;
        const valveDeviceTelemetry =
          analyticsState?.devices?.[device.id] ||
          resolveDeviceTelemetry(device);
        const valveLiveMetrics = {
          battery: valveDeviceTelemetry?.battery !== undefined ? `${valveDeviceTelemetry.battery}%` : (info.battery || '‚Äî'),
          pressure: valveDeviceTelemetry?.pressure !== undefined ? `${valveDeviceTelemetry.pressure} PSI` : (info.pressure || '‚Äî')
        };
        const valveTelemetryDistance = valveDeviceTelemetry?.distance_meters ?? valveDeviceTelemetry?.distanceMeters ?? null;
        const valveDeviceTimestamp = valveDeviceTelemetry?.timestamp ? new Date(valveDeviceTelemetry.timestamp).toLocaleString() : '‚Äî';
        
        return `
          <div class="tooltip-title">
            <i class="fas fa-cog" style="color: #6a1b9a;"></i> 
            ${device.name}
            <span class="status-indicator ${device.active ? 'status-inactive' : 'status-active'}"></span>
            <span class="live-badge">LIVE</span>
          </div>
          
          <div style="font-size: 10px; color: rgba(255,255,255,0.6); margin-bottom: 8px;">
            Last updated: ${timeStr}
          </div>
          
          <div class="tooltip-section">
            <div class="tooltip-section-title">‚ÑπÔ∏è Valve Info</div>
            <div class="tooltip-row">
              <span class="tooltip-label">Type:</span>
              <span class="tooltip-value">${info.type}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Category:</span>
              <span class="tooltip-value">${info.category.toUpperCase()}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Status:</span>
              <span class="tooltip-value" style="color: ${device.active ? '#f44336' : '#4caf50'};">
                ${info.valveState.toUpperCase()}
              </span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Location:</span>
              <span class="tooltip-value">${device.mandal}</span>
            </div>
          </div>
          
          <div class="tooltip-section">
            <div class="tooltip-section-title">üèòÔ∏è Household Supply</div>
            <div class="tooltip-row">
              <span class="tooltip-label">Households:</span>
              <span class="tooltip-value" style="color: #6a1b9a;">${info.households}</span>
            </div>
            ${supplyInfo ? `
              <div class="tooltip-row">
                <span class="tooltip-label">Supply Flow:</span>
                <span class="tooltip-value" style="color: #2196f3;">${supplyInfo.totalFlow.toFixed(1)} L/min</span>
              </div>
              <div class="tooltip-row">
                <span class="tooltip-label">Avg per HH:</span>
                <span class="tooltip-value" style="color: #4caf50;">${supplyInfo.avgSupply.toFixed(2)} L/min</span>
              </div>
            ` : `
              <div style="text-align: center; padding: 8px; color: rgba(255,255,255,0.5); font-size: 11px;">
                ${device.active ? 'üî¥ Valve closed - No supply' : 'No flow data available'}
              </div>
            `}
          </div>
          
          <div class="tooltip-section">
            <div class="tooltip-section-title">üìä Sensors</div>
            <div class="tooltip-row">
              <span class="tooltip-label">Battery:</span>
              <span class="tooltip-value" style="color: ${parseInt(info.battery) > 70 ? '#4caf50' : parseInt(info.battery) > 30 ? '#ff9800' : '#f44336'};">
                ${info.battery}
              </span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Pressure:</span>
              <span class="tooltip-value">${info.pressure}</span>
            </div>
          </div>
          
          <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 10px; color: rgba(255,255,255,0.6); text-align: center;">
            Click for control panel
          </div>
        `;
      } else if (type === 'pipeline') {
        const pipe = device;
        const flowPercentage = pipe.capacity > 0 ? ((pipe.currentFlow / pipe.capacity) * 100).toFixed(1) : 0;
        
        return `
          <div class="tooltip-title">
            <i class="fas fa-pipe" style="color: #1e88e5;"></i> 
            ${pipe.name}
            <span class="status-indicator ${pipe.currentFlow > 0 ? 'status-active' : 'status-inactive'}"></span>
          </div>
          
          <div class="tooltip-section">
            <div class="tooltip-section-title">üîß Pipeline Specs</div>
            <div class="tooltip-row">
              <span class="tooltip-label">Material:</span>
              <span class="tooltip-value">${pipe.type}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Diameter:</span>
              <span class="tooltip-value">${pipe.diameter}mm</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Max Capacity:</span>
              <span class="tooltip-value">${pipe.capacity} L/min</span>
            </div>
          </div>
          
          <div class="tooltip-section">
            <div class="tooltip-section-title">üíß Current Flow</div>
            <div class="tooltip-row">
              <span class="tooltip-label">Flow Rate:</span>
              <span class="tooltip-value" style="color: ${pipe.currentFlow > 0 ? '#4caf50' : '#f44336'};">
                ${pipe.currentFlow.toFixed(0)} L/min
              </span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Capacity Usage:</span>
              <span class="tooltip-value" style="color: ${flowPercentage > 80 ? '#f44336' : flowPercentage > 50 ? '#ff9800' : '#4caf50'};">
                ${flowPercentage}%
              </span>
            </div>
          </div>
          
          <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 10px; color: rgba(255,255,255,0.6); text-align: center;">
            ${pipe.startPoint && pipe.endPoint ? `${pipe.startPoint} ‚Üí ${pipe.endPoint}` : 'Click for details'}
          </div>
        `;
      }
      return '';
    }

    // ==================== MAP INTERACTIONS ====================
    function onMapClick(e) {
      const latLng = e.latlng;
      if(mode === 'erase') return;
      
      const clickedTank = tanks.find(t => distanceInPixels(t, latLng) < CLICK_DETECT_RADIUS);
      if(clickedTank) { showDevice(clickedTank, 'tank'); return; }
      
      const clickedValve = valves.find(v => distanceInPixels(v, latLng) < CLICK_DETECT_RADIUS);
      if(clickedValve) { showDevice(clickedValve, 'valve'); return; }

     if(mode === 'tank') {
  openModal('tankModal');
  setText('tankModalTitle', 'Add Tank');
  setValue('tankLat', latLng.lat.toFixed(6));
  setValue('tankLng', latLng.lng.toFixed(6));
  setValue('tankId', '');
  setValue('tankWaterLevel', '8.5');
  document.getElementById('tankModal').removeAttribute('data-edit-id');
  document.getElementById('tankIdError').textContent = '';
  populateMainValvesList([]); // Populate with empty selection
} else if(mode === 'valve') {
        if(isOnAnyPipeline(latLng, 20)) {
          openModal('valveModal');
          setText('valveModalTitle', 'Add Valve');
          setValue('valveLat', latLng.lat.toFixed(6));
          setValue('valveLng', latLng.lng.toFixed(6));
          setValue('valveId', '');
          setValue('valveCategory', 'sub');
          setValue('valveHouseholds', '10');
          document.getElementById('parentValveRow').style.display = 'block';
          updateParentValveList();
          document.getElementById('valveModal').removeAttribute('data-edit-id');
          document.getElementById('valveIdError').textContent = '';
        } else {
          toast('‚ö†Ô∏è Place valve on a pipeline');
        }
      }
    }

    function onMapRightClick(e) {
      e.originalEvent.preventDefault();
      const {lat, lng} = e.latlng;
      setValue('tankLat', lat.toFixed(6));
      setValue('tankLng', lng.toFixed(6));
      setValue('valveLat', lat.toFixed(6));
      setValue('valveLng', lng.toFixed(6));
      toast('üìç Coordinates filled');
    }

    async function eraseSegmentAtPoint(latLng) {
      let foundSegment = false;
      for(let i = 0; i < pipelines.length; i++) {
        const pipe = pipelines[i];
        for(let j = 0; j < pipe.points.length - 1; j++) {
          if(pointOnSegment(latLng, pipe.points[j], pipe.points[j+1], 20)) {
            foundSegment = true;
            const pipelineName = pipe.name || `Pipeline ${i + 1}`;
            const action = await new Promise(resolve => {
              const modal = document.createElement('div');
              modal.className = 'modal active';
              modal.innerHTML = `
                <div class="modal-content" style="max-width:500px">
                  <div class="modal-header">
                    <h3>Erase Pipeline Segment</h3>
                  </div>
                  <div class="modal-body">
                    <p style="margin-bottom:16px;font-size:14px">
                      <strong>Pipeline:</strong> ${pipelineName}<br>
                      <strong>Segment:</strong> ${j + 1} of ${pipe.points.length - 1}
                    </p>
                    <button class="btn danger" id="eraseSegmentBtn" style="margin-bottom:8px">
                      <i class="fas fa-cut"></i> Split Pipeline Here
                    </button>
                    <button class="btn danger" id="deleteEntireBtn" style="margin-bottom:8px">
                      <i class="fas fa-trash"></i> Delete Entire Pipeline
                    </button>
                    <button class="btn" id="cancelEraseBtn">
                      <i class="fas fa-times"></i> Cancel
                    </button>
                  </div>
                </div>
              `;
              document.body.appendChild(modal);
              document.getElementById('eraseSegmentBtn').onclick = () => { document.body.removeChild(modal); resolve('split'); };
              document.getElementById('deleteEntireBtn').onclick = () => { document.body.removeChild(modal); resolve('delete'); };
              document.getElementById('cancelEraseBtn').onclick = () => { document.body.removeChild(modal); resolve('cancel'); };
            });
            if(action === 'split') {
              const remaining = pipe.points.slice(0, j + 1);
              if(remaining.length > 1) {
                pipe.points = remaining;
                pipe.update({points: remaining});
                await FirebaseService.savePipeline(pipe);
                toast('‚úì Pipeline split');
              } else {
                await FirebaseService.deletePipeline(pipe.id);
                toast('‚úì Pipeline deleted');
              }
            } else if(action === 'delete') {
              await FirebaseService.deletePipeline(pipe.id);
              toast('‚úì Pipeline deleted');
            } else {
              toast('‚ùå Erase cancelled');
            }
            flowCacheDirty = true;
            requestDrawCanvas();
            requestSupplyDashboardUpdate();
            return;
          }
        }
      }
      if(!foundSegment) toast('‚ö†Ô∏è Click on a pipeline segment');
    }

    // ==================== CANVAS DRAWING ====================
    function handleCanvasMouseDown(e) {
      if(mode === 'erase') {
        e.preventDefault(); e.stopPropagation();
        const latLng = pixelToLatLng(eventToPixel(e));
        eraseSegmentAtPoint(latLng);
        return;
      }
      if(mode !== 'pipeline') return;
      e.preventDefault(); e.stopPropagation();
      const latLng = pixelToLatLng(eventToPixel(e));
      isDrawing = true;
      currentPipeline = [latLng];
      canvas.classList.add('drawing');
    }

    function handleCanvasMouseMove(e) {
      const px = eventToPixel(e);
      const latLng = pixelToLatLng(px);
      
      // Handle hover tooltips
      const hoveredTank = tanks.find(t => distanceInPixels(t, latLng) < CLICK_DETECT_RADIUS);
      const hoveredValve = valves.find(v => distanceInPixels(v, latLng) < CLICK_DETECT_RADIUS);
      let hoveredPipeline = null;
      
      if(mode === 'erase') {
        for(let i = 0; i < pipelines.length; i++) {
          const pipe = pipelines[i];
          for(let j = 0; j < pipe.points.length - 1; j++) {
            if(pointOnSegment(latLng, pipe.points[j], pipe.points[j+1], 20)) {
              hoveredPipeline = {pipe, segmentIndex: j};
              break;
            }
          }
          if(hoveredPipeline) break;
        }
      }
      
      hoveredDevice = hoveredTank ? {type:'tank', device:hoveredTank} : 
                      hoveredValve ? {type:'valve', device:hoveredValve} : 
                      hoveredPipeline ? {type:'pipeline', data:hoveredPipeline} : null;
      
      // Show/hide tooltip based on hover state
      if (hoveredDevice) {
        const tooltipContent = createTooltipContent(
          hoveredDevice.type === 'pipeline' ? hoveredDevice.data.pipe : hoveredDevice.device,
          hoveredDevice.type
        );
        showHoverTooltip(tooltipContent, e.clientX, e.clientY);
      } else {
        hideHoverTooltip();
      }
      
      if(mode === 'erase') canvas.style.cursor = hoveredPipeline ? 'crosshair' : 'not-allowed';
      
      if(isDrawing && mode === 'pipeline') {
        e.preventDefault();
        const lastLatLng = currentPipeline[currentPipeline.length-1];
        const lastPx = latLngToPixel(lastLatLng);
        if(distanceBetweenPixels(lastPx, px) > 3) {
          currentPipeline.push(latLng);
          requestDrawCanvas();
        }
      }
    }

    async function handleCanvasMouseUp(e) {
      if(!isDrawing) return;
      e.preventDefault(); e.stopPropagation();
      if(currentPipeline.length > 5) {
        const newPipe = new Pipeline({points: currentPipeline});
        await FirebaseService.savePipeline(newPipe);
        toast('‚úì Pipeline created!');
        openPipelineDetailsModal(newPipe.id);
      } else {
        toast('‚ö†Ô∏è Pipeline too short');
      }
      currentPipeline = [];
      isDrawing = false;
      canvas.classList.remove('drawing');
      map.dragging.enable();
      map.scrollWheelZoom.enable();
      flowCacheDirty = true;
      requestDrawCanvas();
      requestSupplyDashboardUpdate();
    }

    function openPipelineDetailsModal(pipeId) {
      const pipe = pipelines.find(p => p.id === pipeId);
      if(!pipe) return;
      openModal('pipelineModal');
      setValue('pipelineName', pipe.name);
      setValue('pipelineType', pipe.type);
      setValue('pipelineDiameter', pipe.diameter);
      setValue('pipelineCapacity', pipe.capacity);
      setValue('pipelineStart', pipe.startPoint);
      setValue('pipelineEnd', pipe.endPoint);
      setValue('pipelineNotes', pipe.notes);
      document.getElementById('pipelineModal').setAttribute('data-pipe-id', pipeId);
    }

    async function onSavePipeline() {
      const pipeId = document.getElementById('pipelineModal').getAttribute('data-pipe-id');
      const pipe = pipelines.find(p => p.id === pipeId);
      if(!pipe) return;

      const name = val('pipelineName').trim();
      const type = val('pipelineType');
      const diameter = parseFloat(val('pipelineDiameter'));
      const capacity = parseFloat(val('pipelineCapacity'));
      const startPoint = val('pipelineStart').trim();
      const endPoint = val('pipelineEnd').trim();
      const notes = val('pipelineNotes').trim();

      if(!name || isNaN(diameter) || isNaN(capacity)) { toast('‚ö†Ô∏è Fill all required fields'); return; }

      pipe.update({name, type, diameter, capacity, startPoint, endPoint, notes});
      await FirebaseService.savePipeline(pipe);
      closeModal('pipelineModal');
      toast('‚úì Pipeline saved');
      flowCacheDirty = true;
      requestDrawCanvas();
      requestSupplyDashboardUpdate();
      setMode('pipeline');
    }

    // ==================== SEARCH ====================
    function levenshteinDistance(a, b) {
      const matrix = [];
      for(let i = 0; i <= b.length; i++) matrix[i] = [i];
      for(let j = 0; j <= a.length; j++) matrix[0][j] = j;
      for(let i = 1; i <= b.length; i++) {
        for(let j = 1; j <= a.length; j++) {
          if(b.charAt(i-1) === a.charAt(j-1)) matrix[i][j] = matrix[i-1][j-1];
          else matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, matrix[i][j-1] + 1, matrix[i-1][j] + 1);
        }
      }
      return matrix[b.length][a.length];
    }

    function fuzzyMatch(query, target) {
      const q = query.toLowerCase();
      const t = target.toLowerCase();
      if(t.includes(q)) return 100;
      const distance = levenshteinDistance(q, t);
      const maxLen = Math.max(q.length, t.length);
      return Math.max(0, 100 - (distance / maxLen) * 100);
    }

    async function onSearchInput() {
      const query = document.getElementById('searchInput').value.trim();
      if(!query || query.length < 2) { hideSuggestions(); return; }
      showLoadingSuggestions();
      const deviceResults = searchDevices(query);
      const locationResults = await searchLocations(query);
      renderSuggestions(deviceResults, locationResults);
    }

    function searchDevices(query) {
      const q = query.toLowerCase();
      const results = [];
      tanks.forEach(t => {
        const nameScore = fuzzyMatch(q, t.name);
        const idScore = fuzzyMatch(q, t.id);
        const locationScore = Math.max(
          fuzzyMatch(q, t.state || ''),
          fuzzyMatch(q, t.district || ''),
          fuzzyMatch(q, t.mandal || ''),
          fuzzyMatch(q, t.habitation || '')
        );
        const score = Math.max(nameScore, idScore, locationScore);
        if(score > 50) results.push({type:'tank', device:t, score});
      });
      valves.forEach(v => {
        const nameScore = fuzzyMatch(q, v.name);
        const idScore = fuzzyMatch(q, v.id);
        const locationScore = Math.max(
          fuzzyMatch(q, v.mandal || ''),
          fuzzyMatch(q, v.habitation || '')
        );
        const score = Math.max(nameScore, idScore, locationScore);
        if(score > 50) results.push({type:'valve', device:v, score});
      });
      results.sort((a, b) => b.score - a.score);
      return results.slice(0, 5);
    }

    async function searchLocations(query) {
      try {
        const response = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&countrycodes=in`,
          { headers: { 'User-Agent': 'WaterDistributionApp/1.0' } }
        );
        if(!response.ok) return [];
        const data = await response.json();
        return data.map(place => ({
          name: place.display_name,
          lat: parseFloat(place.lat),
          lng: parseFloat(place.lon),
          type: place.type,
          importance: place.importance || 0
        }));
      } catch(error) { console.error('Location search error:', error); return []; }
    }

    function renderSuggestions(devices, locations) {
      const holder = document.getElementById('suggestions');
      const list = document.getElementById('suggestList');
      
      if(devices.length === 0 && locations.length === 0) {
        list.innerHTML = '<div class="suggest-item" style="text-align:center;color:var(--muted)">No results found</div>';
        holder.style.display = 'block';
        return;
      }

      let html = '';
      if(devices.length > 0) {
        html += '<div class="suggest-item header">DEVICES</div>';
        devices.forEach(d => {
          const icon = d.type === 'tank' ? 'fa-water' : 'fa-cog';
          const color = d.type === 'tank' ? '#0288d1' : '#6a1b9a';
          const location = d.device.habitation || d.device.mandal || 'Unknown';
          html += `<div class="suggest-item" data-type="device" data-device-type="${d.type}" data-device-id="${d.device.id}">
            <i class="fas ${icon}" style="color:${color};font-size:18px"></i>
            <div style="flex:1">
              <div style="font-weight:600">${d.device.name}</div>
              <div style="font-size:11px;color:var(--muted)">${d.device.id} ‚Ä¢ ${location}</div>
            </div>
            <span class="match-score">${d.score.toFixed(0)}%</span>
          </div>`;
        });
      }
      if(locations.length > 0) {
        html += '<div class="suggest-item header">LOCATIONS</div>';
        locations.forEach((loc, idx) => {
          const icon = getLocationIcon(loc.type);
          html += `<div class="suggest-item" data-type="location" data-location-index="${idx}">
            <i class="fas ${icon}" style="color:#e67e22;font-size:18px"></i>
            <div style="flex:1">
              <div style="font-weight:600">${getLocationTitle(loc.name)}</div>
              <div style="font-size:11px;color:var(--muted)">${getLocationSubtitle(loc.name)}</div>
            </div>
            <i class="fas fa-map-marker-alt" style="color:var(--muted);font-size:12px"></i>
          </div>`;
        });
      }
      list.innerHTML = html;

      list.querySelectorAll('.suggest-item[data-type="device"]').forEach(item => {
        item.addEventListener('click', () => {
          const deviceType = item.getAttribute('data-device-type');
          const deviceId = item.getAttribute('data-device-id');
          const device = deviceType === 'tank' ? tanks.find(t => t.id === deviceId) : valves.find(v => v.id === deviceId);
          if(device) {
            map.setView([device.lat, device.lng], 17);
            showDevice(device, deviceType);
            hideSuggestions();
            document.getElementById('searchInput').value = '';
          }
        });
      });

      list.querySelectorAll('.suggest-item[data-type="location"]').forEach(item => {
        item.addEventListener('click', () => {
          const index = parseInt(item.getAttribute('data-location-index'));
          const location = locations[index];
          if(location) {
            map.setView([location.lat, location.lng], 15);
            addTemporaryMarker(location);
            hideSuggestions();
            document.getElementById('searchInput').value = getLocationTitle(location.name);
            toast(`üìç ${getLocationTitle(location.name)}`);
          }
        });
      });

      holder.style.display = 'block';
    }

    function getLocationIcon(type) {
      const iconMap = { city:'fa-city', town:'fa-building', village:'fa-home', hamlet:'fa-house', administrative:'fa-landmark', state:'fa-map', district:'fa-map-marked', suburb:'fa-building', neighbourhood:'fa-map-pin', road:'fa-road', residential:'fa-home' };
      return iconMap[type] || 'fa-map-marker-alt';
    }

    function getLocationTitle(displayName) {
      const parts = displayName.split(',');
      return parts[0].trim();
    }

    function getLocationSubtitle(displayName) {
      const parts = displayName.split(',');
      if(parts.length > 1) return parts.slice(1, 3).join(',').trim();
      return '';
    }

    let temporaryMarker = null;
    function addTemporaryMarker(location) {
      if(temporaryMarker) map.removeLayer(temporaryMarker);
      temporaryMarker = L.marker([location.lat, location.lng], {
        icon: L.divIcon({
          className: 'temp-location-marker',
          html: '<div style="background:#e67e22;width:24px;height:24px;border-radius:50%;border:3px solid white;box-shadow:0 2px 8px rgba(0,0,0,0.3)"></div>',
          iconSize: [24, 24],
          iconAnchor: [12, 12]
        })
      }).addTo(map);
      temporaryMarker.bindPopup(`
        <div style="padding:8px">
          <strong>${getLocationTitle(location.name)}</strong><br>
          <small style="color:#666">${getLocationSubtitle(location.name)}</small>
        </div>
      `).openPopup();
      setTimeout(() => { if(temporaryMarker) { map.removeLayer(temporaryMarker); temporaryMarker = null; } }, 10000);
    }

    function showLoadingSuggestions() {
      const holder = document.getElementById('suggestions');
      const list = document.getElementById('suggestList');
      list.innerHTML = '<div class="suggest-item" style="text-align:center"><i class="fas fa-spinner fa-spin"></i> Searching...</div>';
      holder.style.display = 'block';
    }

    function hideSuggestions() { document.getElementById('suggestions').style.display = 'none'; }

    async function executeSearch() {
      const query = document.getElementById('searchInput').value.trim().toLowerCase();
      if(!query) { toast('‚ö†Ô∏è Enter search query'); return; }
      let device = [...tanks, ...valves].find(d => d.id.toLowerCase() === query);
      if(!device) {
        const matches = [...tanks, ...valves].filter(d => 
          fuzzyMatch(query, d.name) > 70 || fuzzyMatch(query, d.id) > 70
        ).sort((a, b) => {
          const scoreA = Math.max(fuzzyMatch(query, a.name), fuzzyMatch(query, a.id));
          const scoreB = Math.max(fuzzyMatch(query, b.name), fuzzyMatch(query, b.id));
          return scoreB - scoreA;
        });
        if(matches.length > 0) device = matches[0];
      }
      if(device) {
        const type = tanks.includes(device) ? 'tank' : 'valve';
        map.setView([device.lat, device.lng], 17);
        showDevice(device, type);
        hideSuggestions();
        toast(`‚úì Found: ${device.name}`);
        return;
      }
      showLoading(true);
      const locations = await searchLocations(query);
      showLoading(false);
      if(locations.length > 0) {
        const location = locations[0];
        map.setView([location.lat, location.lng], 15);
        addTemporaryMarker(location);
        hideSuggestions();
        toast(`üìç ${getLocationTitle(location.name)}`);
        return;
      }
      toast('‚ùå No results found');
    }

    // ==================== CRUD ====================
    function validateDeviceId(id, excludeId = null) {
      if(!id || id.trim().length === 0) return 'Device ID is required';
      const trimmedId = id.trim();
      if(trimmedId.length > 50) return 'Device ID must be 50 characters or less';
      const exists = [...tanks, ...valves].some(d => d.id === trimmedId && d.id !== excludeId);
      if(exists) return 'Device ID already exists';
      return null;
    }

   async function onSaveTank() {
  const id = val('tankId').trim();
  const name = val('tankName').trim();
  const type = val('tankType');
  const shape = val('tankShape');
  const capacity = parseFloat(val('tankCapacity'));
  const waterLevel = parseFloat(val('tankWaterLevel'));
  // Normalize device ID: trim, convert to uppercase for consistency
  let deviceId = val('tankDeviceId').trim() || null;
  if (deviceId) {
    deviceId = deviceId.toUpperCase(); // Normalize to uppercase for consistency with Firebase keys
  }
  const lat = parseFloat(val('tankLat'));
  const lng = parseFloat(val('tankLng'));
  const state = val('tankState').trim();
  const district = val('tankDistrict').trim();
  const mandal = val('tankMandal').trim();
  const habitation = val('tankHabitation').trim();
  
  // Get dimensions based on shape
  let diameter, height, length, breadth, sensorHeight;
  if(shape === 'cylinder') {
    diameter = parseFloat(val('tankDiameter'));
    height = parseFloat(val('tankHeight'));
    sensorHeight = parseFloat(val('tankSensorHeight')) || height;
    if(isNaN(diameter) || isNaN(height)) {
      toast('‚ö†Ô∏è Enter valid cylinder dimensions');
      return;
    }
  } else if(shape === 'cuboid') {
    length = parseFloat(val('tankLength'));
    breadth = parseFloat(val('tankBreadth'));
    height = parseFloat(val('tankHeightCuboid'));
    sensorHeight = parseFloat(val('tankSensorHeight')) || height;
    if(isNaN(length) || isNaN(breadth) || isNaN(height)) {
      toast('‚ö†Ô∏è Enter valid cuboid dimensions');
      return;
    }
  }
  
  // Get selected main valves
  // Get selected main valves from global storage
  const selectedValves = window.currentSelectedValves || [];

  const editingId = document.getElementById('tankModal').getAttribute('data-edit-id');
  const idError = validateDeviceId(id, editingId);
  if(idError) { 
    document.getElementById('tankIdError').textContent = idError; 
    return; 
  }
  if(!name || isNaN(lat) || isNaN(lng) || isNaN(capacity) || isNaN(waterLevel)) { 
    toast('‚ö†Ô∏è Fill all required fields'); 
    return; 
  }

  // Build tankData object with shape-specific fields
  const tankData = {
    id, name, type, shape, capacity, waterLevel, 
    height, sensorHeight,
    deviceId, state, district, mandal, habitation, lat, lng,
    connectedMainValves: selectedValves
  };
  
  // Only include shape-specific dimensions (don't set undefined values)
  if(shape === 'cylinder') {
    tankData.diameter = diameter;
  } else if(shape === 'cuboid') {
    tankData.length = length;
    tankData.breadth = breadth;
  }

  if(editingId) {
    const tank = tanks.find(t => t.id === editingId);
    if(tank) {
      // When updating, preserve existing values for fields not relevant to current shape
      // Only update the fields that are provided in tankData
      const updateData = { ...tankData };
      // Remove shape-incompatible fields from existing tank
      if(shape === 'cylinder') {
        delete updateData.length;
        delete updateData.breadth;
      } else if(shape === 'cuboid') {
        delete updateData.diameter;
      }
      tank.update(updateData);
      await FirebaseService.saveTank(tank);
      toast('‚úì Tank updated');
    }
  } else {
    const tank = new Tank(tankData);
    await FirebaseService.saveTank(tank);
    toast('‚úì Tank added');
  }
  
  document.getElementById('tankModal').removeAttribute('data-edit-id');
  document.getElementById('tankIdError').textContent = '';
  closeModal('tankModal');
  flowCacheDirty = true;
  requestDrawCanvas();
  requestSupplyDashboardUpdate();
  setMode('pipeline');
}

async function onSaveValve() {
  const id = val('valveId').trim();
  const name = val('valveName').trim();
  const type = val('valveType');
  const category = val('valveCategory');
  const parentValveId = category === 'sub' ? val('parentValve') : null;
  const households = parseInt(val('valveHouseholds'));
  const flowRate = parseFloat(val('valveFlowRate')); // NEW
  const lat = parseFloat(val('valveLat'));
  const lng = parseFloat(val('valveLng'));
  const mandal = val('valveMandal').trim();
  const habitation = val('valveHabitation').trim();

      const editingId = document.getElementById('valveModal').getAttribute('data-edit-id');
      const idError = validateDeviceId(id, editingId);
      if(idError) { document.getElementById('valveIdError').textContent = idError; return; }
      if(!name || isNaN(lat) || isNaN(lng) || isNaN(households)) { toast('‚ö†Ô∏è Fill all required fields'); return; }

      if(editingId) {
  const valve = valves.find(v => v.id === editingId);
  if(valve) {
    valve.update({id, name, type, category, parentValveId, households, flowRate, mandal, habitation, lat, lng});
    await FirebaseService.saveValve(valve);
    toast('‚úì Valve updated');
  }
} else {
  if(!isOnAnyPipeline({lat, lng}, 20)) { toast('‚ö†Ô∏è Valve must be on a pipeline'); return; }
  const valve = new Valve({id, name, type, category, parentValveId, households, flowRate, mandal, habitation, lat, lng});
  await FirebaseService.saveValve(valve);
  toast('‚úì Valve added');
}
      document.getElementById('valveModal').removeAttribute('data-edit-id');
      document.getElementById('valveIdError').textContent = '';
      closeModal('valveModal');
      flowCacheDirty = true;
      requestDrawCanvas();
  requestSupplyDashboardUpdate();
    }

    function editTank(id) {
  const tank = tanks.find(t => t.id === id);
  if(!tank) return;
  
  setText('tankModalTitle', 'Edit Tank');
  openModal('tankModal');
  document.getElementById('tankModal').setAttribute('data-edit-id', id);
  
  setValue('tankId', tank.id);
  setValue('tankName', tank.name);
  setValue('tankType', tank.type);
  setValue('tankShape', tank.shape || (tank.type === 'GSR' ? 'cuboid' : 'cylinder'));
  setValue('tankCapacity', tank.capacity);
  setValue('tankWaterLevel', tank.waterLevel);
  
  // Set dimensions
  if(tank.shape === 'cylinder' || !tank.shape) {
    setValue('tankDiameter', tank.diameter || 10);
    setValue('tankHeight', tank.height || 10);
    document.getElementById('cylinderDimensions').style.display = 'block';
    document.getElementById('cuboidDimensions').style.display = 'none';
  } else {
    setValue('tankLength', tank.length || 10);
    setValue('tankBreadth', tank.breadth || 10);
    setValue('tankHeightCuboid', tank.height || 10);
    document.getElementById('cylinderDimensions').style.display = 'none';
    document.getElementById('cuboidDimensions').style.display = 'block';
  }
  
  setValue('tankDeviceId', tank.deviceId || '');
  setValue('tankSensorHeight', tank.sensorHeight || tank.height || 10);
  setValue('tankState', tank.state);
  setValue('tankDistrict', tank.district);
  setValue('tankMandal', tank.mandal);
  setValue('tankHabitation', tank.habitation);
  setValue('tankLat', tank.lat);
  setValue('tankLng', tank.lng);
  
  document.getElementById('tankIdError').textContent = '';
  populateMainValvesList(tank.connectedMainValves || []);
}

    function editValve(id) {
  const valve = valves.find(v => v.id === id);
  if(!valve) return;
  setText('valveModalTitle', 'Edit Valve');
  openModal('valveModal');
  document.getElementById('valveModal').setAttribute('data-edit-id', id);
  setValue('valveId', valve.id);
  setValue('valveName', valve.name);
  setValue('valveType', valve.type);
  setValue('valveCategory', valve.category);
  setValue('valveHouseholds', valve.households);
  setValue('valveFlowRate', valve.flowRate); // NEW
  setValue('valveMandal', valve.mandal);
  setValue('valveHabitation', valve.habitation);
  setValue('valveLat', valve.lat);
  setValue('valveLng', valve.lng);
      if(valve.category === 'sub') {
        document.getElementById('parentValveRow').style.display = 'block';
        updateParentValveList();
        setValue('parentValve', valve.parentValveId || '');
      } else {
        document.getElementById('parentValveRow').style.display = 'none';
      }
      document.getElementById('valveIdError').textContent = '';
    }

    async function deleteTank(id) {
      if(!confirm('Delete this tank?')) return;
      await FirebaseService.deleteTank(id);
      closeSidebar();
      flowCacheDirty = true;
      requestDrawCanvas();
      requestSupplyDashboardUpdate();
      toast('‚úì Tank deleted');
      if(document.getElementById('manageModal').classList.contains('active')) renderManage('tanks');
    }

    async function deleteValve(id) {
      if(!confirm('Delete this valve?')) return;
      await FirebaseService.deleteValve(id);
      closeSidebar();
      flowCacheDirty = true;
      requestDrawCanvas();
      requestSupplyDashboardUpdate();
      toast('‚úì Valve deleted');
      if(document.getElementById('manageModal').classList.contains('active')) renderManage('valves');
    }

    async function deletePipeline(id) {
      if(!confirm('Delete this pipeline?')) return;
      await FirebaseService.deletePipeline(id);
      flowCacheDirty = true;
      requestDrawCanvas();
      requestSupplyDashboardUpdate();
      toast('‚úì Pipeline deleted');
      renderManage('pipelines');
      closeModal('pipelineModal');
    }

    function editPipeline(id) { openPipelineDetailsModal(id); }

    function centerPipeline(id) {
      const pipe = pipelines.find(p => p.id === id);
      if(!pipe || pipe.points.length === 0) return;
      const mid = pipe.points[Math.floor(pipe.points.length / 2)];
      map.setView([mid.lat, mid.lng], Math.max(map.getZoom(), 16));
      closeModal('manageModal');
    }

    async function clearAll() {
      if(!confirm('‚ö†Ô∏è Clear ALL data?')) return;
      showLoading(true);
      await FirebaseService.clearAll();
      isDrawing = false;
      currentPipeline = [];
      closeSidebar();
      flowCacheDirty = true;
      requestDrawCanvas();
      requestSupplyDashboardUpdate();
      showLoading(false);
      toast('‚úì All data cleared');
    }

    // ==================== MANAGE MODAL ====================
    function openManage() {
      openModal('manageModal');
      document.querySelectorAll('#manageModal [data-tab]').forEach(b => b.classList.remove('primary'));
      document.querySelector('#manageModal [data-tab="tanks"]').classList.add('primary');
      renderManage('tanks');
    }

    function renderManage(tab) {
      const content = document.getElementById('manageContent');
      if(tab === 'tanks') {
        if(tanks.length === 0) { content.innerHTML = '<div class="card" style="text-align:center;color:var(--muted)">No tanks</div>'; return; }
        content.innerHTML = '<div class="manage-list">' + tanks.map(t => `
          <div class="manage-item">
            <div class="manage-item-info">
              <div class="manage-item-title">${t.name}</div>
              <div class="manage-item-meta">${t.id} ‚Ä¢ ${t.type} ‚Ä¢ ${t.capacity}L</div>
            </div>
            <div class="manage-item-actions">
              <button class="btn primary" onclick="viewTank('${t.id}')"><i class="fas fa-eye"></i></button>
              <button class="btn" onclick="editTank('${t.id}')"><i class="fas fa-pen"></i></button>
              <button class="btn danger" onclick="deleteTank('${t.id}')"><i class="fas fa-trash"></i></button>
            </div>
          </div>
        `).join('') + '</div>';
      } else if(tab === 'valves') {
        if(valves.length === 0) { content.innerHTML = '<div class="card" style="text-align:center;color:var(--muted)">No valves</div>'; return; }
        
        const { valveTree } = calculateHouseholdStats();
        
        content.innerHTML = '<div class="manage-list">' + valves.map(v => {
          const node = valveTree.get(v.id);
          let householdInfo = `${v.households} HH`;
          
          if(node && v.category === 'main') {
            const subTotal = node.totalHouseholds - node.directHouseholds;
            householdInfo = `Total: ${node.totalHouseholds} HH (${node.directHouseholds} direct + ${subTotal} sub-valves)`;
          }
          
          return `
          <div class="manage-item">
            <div class="manage-item-info">
              <div class="manage-item-title">${v.name}</div>
              <div class="manage-item-meta">${v.id} ‚Ä¢ ${v.category.toUpperCase()} ‚Ä¢ ${householdInfo}</div>
            </div>
            <div class="manage-item-actions">
              <button class="btn primary" onclick="viewValve('${v.id}')"><i class="fas fa-eye"></i></button>
              <button class="btn" onclick="editValve('${v.id}')"><i class="fas fa-pen"></i></button>
              <button class="btn danger" onclick="deleteValve('${v.id}')"><i class="fas fa-trash"></i></button>
            </div>
          </div>
        `;
        }).join('') + '</div>';
      } else if(tab === 'pipelines') {
        if(pipelines.length === 0) { content.innerHTML = '<div class="card" style="text-align:center;color:var(--muted)">No pipelines</div>'; return; }
        content.innerHTML = '<div class="manage-list">' + pipelines.map(p => `
          <div class="manage-item">
            <div class="manage-item-info">
              <div class="manage-item-title">${p.name}</div>
              <div class="manage-item-meta">${p.type} ‚Ä¢ ${p.diameter}mm ‚Ä¢ ${p.capacity}L/min</div>
            </div>
            <div class="manage-item-actions">
              <button class="btn primary" onclick="centerPipeline('${p.id}')"><i class="fas fa-crosshairs"></i></button>
              <button class="btn" onclick="editPipeline('${p.id}')"><i class="fas fa-pen"></i></button>
              <button class="btn danger" onclick="deletePipeline('${p.id}')"><i class="fas fa-trash"></i></button>
            </div>
          </div>
        `).join('') + '</div>';
      } else if(tab === 'data') {
        const { stats } = calculateHouseholdStats();
        content.innerHTML = `
          <div class="card">
            <h4><i class="fas fa-cloud"></i> FIREBASE STATUS</h4>
            <div class="row"><span class="label">Connection</span><span class="value" style="color:${isFirebaseConnected ? 'var(--success)' : 'var(--danger)'}">${isFirebaseConnected ? 'Connected' : 'Disconnected'}</span></div>
          </div>
          <div class="household-stats">
            <h4><i class="fas fa-home"></i> HOUSEHOLD STATISTICS</h4>
            <div class="stat-big">
              <div class="stat-big-number">${stats.servedHouseholds}</div>
              <div class="stat-big-label">Households Currently Served</div>
            </div>
            <div class="stat-row">
              <span class="label">Total Households</span>
              <span class="value">${stats.totalHouseholds}</span>
            </div>
            <div class="stat-row">
              <span class="label">Main Valves</span>
              <span class="value">${stats.mainValves.length}</span>
            </div>
            <div class="stat-row">
              <span class="label">Coverage</span>
              <span class="value">${stats.totalHouseholds > 0 ? ((stats.servedHouseholds / stats.totalHouseholds) * 100).toFixed(1) : 0}%</span>
            </div>
            <div class="stat-row">
              <span class="label">Total Supply Flow</span>
              <span class="value">${stats.totalSupplyFlow.toFixed(0)} L/min</span>
            </div>
            <div class="stat-row">
              <span class="label">Avg Supply/HH</span>
              <span class="value">${stats.averageSupplyPerHousehold.toFixed(1)} L/min</span>
            </div>
          </div>
          <div class="card">
            <h4><i class="fas fa-file-export"></i> EXPORT DATA</h4>
            <button class="btn success" onclick="exportData()"><i class="fas fa-download"></i> Export JSON</button>
          </div>
          <div class="card">
            <h4><i class="fas fa-file-import"></i> IMPORT DATA</h4>
            <button class="btn primary" onclick="document.getElementById('importFile').click()"><i class="fas fa-upload"></i> Import JSON</button>
          </div>
          <div class="card">
            <h4><i class="fas fa-info-circle"></i> STATISTICS</h4>
            <div class="row"><span class="label">Tanks</span><span class="value">${tanks.length}</span></div>
            <div class="row"><span class="label">Valves</span><span class="value">${valves.length}</span></div>
            <div class="row"><span class="label">Pipelines</span><span class="value">${pipelines.length}</span></div>
            <div class="row"><span class="label">Total capacity</span><span class="value">${tanks.reduce((sum, t) => sum + t.capacity, 0).toLocaleString()} L</span></div>
          </div>
        `;
      }
    }

    function viewDevice(id, type) {
      const device = type === 'tank' ? tanks.find(t => t.id === id) : valves.find(v => v.id === id);
      if(device) {
        closeModal('manageModal');
        map.setView([device.lat, device.lng], 17);
        showDevice(device, type);
      }
    }
    function viewTank(id) { viewDevice(id, 'tank'); }
    function viewValve(id) { viewDevice(id, 'valve'); }

    // ==================== IMPORT/EXPORT ====================
    async function exportData() {
      const data = {
        tanks: tanks.map(t => t.toFirebase()),
        valves: valves.map(v => v.toFirebase()),
        pipelines: pipelines.map(p => p.toFirebase()),
        version: '3.0-optimized',
        timestamp: Date.now(),
        exportDate: new Date().toISOString()
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `water-system-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      toast('‚úì Data exported');
    }

    async function importData(e) {
      const file = e.target.files[0];
      if(!file) return;
      showLoading(true);
      const reader = new FileReader();
      reader.onload = async () => {
        try {
          const data = JSON.parse(reader.result);
          if(data.tanks && Array.isArray(data.tanks)) {
            for(const tankData of data.tanks) { const tank = new Tank(tankData); await FirebaseService.saveTank(tank); }
          }
          if(data.valves && Array.isArray(data.valves)) {
            for(const valveData of data.valves) { const valve = new Valve(valveData); await FirebaseService.saveValve(valve); }
          }
          if(data.pipelines && Array.isArray(data.pipelines)) {
            for(const pipelineData of data.pipelines) { const pipeline = new Pipeline(pipelineData); await FirebaseService.savePipeline(pipeline); }
          }
          showLoading(false);
          flowCacheDirty = true;
          requestDrawCanvas();
          requestSupplyDashboardUpdate();
          toast('‚úì Data imported');
          if(document.getElementById('manageModal').classList.contains('active')) renderManage('data');
        } catch(error) {
          console.error('Import error:', error);
          showLoading(false);
          toast('‚ö†Ô∏è Invalid JSON file');
        }
      };
      reader.readAsText(file);
      e.target.value = '';
    }








    // ==================== HISTORY ====================
    let currentHistoryDevice = null;
    let currentHistoryType = null;
    let currentHistoryData = [];

    function updateHistoryDeviceCard(device, telemetry) {
      const card = document.getElementById('historyDeviceCard');
      if(!card) return;
      if(!telemetry) {
        card.style.display = 'none';
        return;
      }

      const readableTimestamp = telemetry.timestamp ? new Date(telemetry.timestamp).toLocaleString() : '‚Äî';
      const distanceRaw = telemetry.distance_meters ?? telemetry.distanceMeters ?? telemetry.distance ?? null;
      const distanceValue = Number(distanceRaw);
      const readingsValue = telemetry.reading_count ?? telemetry.readingCount ?? telemetry.readings ?? null;

      card.style.display = 'block';
      setText('historyDeviceId', telemetry.id || device.id || '‚Äî');
      setText('historyDeviceLastUpdate', readableTimestamp);
      setText('historyDeviceDistance', Number.isFinite(distanceValue) ? `${distanceValue.toFixed(2)} m` : '‚Äî');
      setText('historyDeviceReadings', readingsValue ?? '‚Äî');
    }

    async function openHistory(deviceId, deviceType) {
  currentHistoryDevice = deviceId;
  currentHistoryType = deviceType;
  
  const device = deviceType === 'tanks' ? 
    tanks.find(t => t.id === deviceId) : 
    valves.find(v => v.id === deviceId);
  
  if(!device) return;
  
  openModal('historyModal');
  setText('historyModalTitle', `${device.name} - History`);

  const analyticsEntry = deviceType === 'tanks'
    ? analyticsState?.tanks?.[device.id]
    : analyticsState?.valves?.[device.id];
  const fallbackTelemetry = analyticsEntry?.device || resolveDeviceTelemetry(device);
  updateHistoryDeviceCard(device, fallbackTelemetry);
  
  // Set default date range (last 30 days)
  const endDate = new Date();
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - 30);
  
  document.getElementById('historyStartDate').valueAsDate = startDate;
  document.getElementById('historyEndDate').valueAsDate = endDate;
  
  // Show loading state
  const historyContent = document.getElementById('historyContent');
  historyContent.innerHTML = `
    <div style="text-align: center; padding: 40px; color: var(--muted);">
      <i class="fas fa-spinner fa-spin" style="font-size: 32px;"></i>
      <div style="margin-top: 12px;">Checking for latest device data...</div>
    </div>
  `;
  
  // üî• CRITICAL FIX: Auto-sync device data BEFORE loading history
  console.log('üîÑ Auto-syncing device data before loading history...');
  
  try {
    // Fetch all device data directly from Firebase
    const allDeviceData = await FirebaseService.fetchAllDeviceData();
    
    if (Object.keys(allDeviceData).length > 0) {
      const skipPaths = ['tanks', 'valves', 'pipelines', 'analytics', 'ultrasonic', 'history'];
      
      // Find the tank being viewed and its linked device
      const currentTank = deviceType === 'tanks' ? device : null;
      
      if (currentTank && currentTank.deviceId) {
        const targetDeviceId = currentTank.deviceId.toUpperCase();
        console.log(`üîç Looking for device: ${targetDeviceId} for tank: ${currentHistoryDevice}`);
        
        // Process only the relevant device
        for (const deviceId of Object.keys(allDeviceData)) {
          if (skipPaths.includes(deviceId)) continue;
          
          // Check if this device matches the tank's device ID
          if (deviceId.toUpperCase() === targetDeviceId) {
            const deviceNode = allDeviceData[deviceId];
            if (!deviceNode || typeof deviceNode !== 'object') continue;
            
            // Extract all readings from this device
            const allReadings = FirebaseService.extractAllReadings(deviceNode);
            
            if (allReadings.length > 0) {
              console.log(`üîÑ Syncing ${allReadings.length} readings for device ${deviceId} ‚Üí tank ${currentTank.id}`);
              
              // Sync with tank object for calculations
              const result = await HistoryService.syncDeviceReadingsToHistory(
                currentTank.id, 
                'tanks', 
                allReadings, 
                currentTank
              );
              
              if (result.synced > 0) {
                console.log(`‚úÖ Synced ${result.synced} new readings`);
                toast(`‚úÖ Synced ${result.synced} new readings to history`);
              } else {
                console.log(`üìã All data already synced (${result.skipped} existing)`);
              }
            }
            break; // Found the device, no need to continue
          }
        }
      }
    }
  } catch (error) {
    console.error('‚ö†Ô∏è Error auto-syncing device data:', error);
    // Continue to load history even if sync fails
  }
  
  // Now load history from Firebase
  console.log('üìñ Loading history from Firebase...');
  await loadHistory();
}







// üî• NEW FUNCTION: Extract readings with REAL Firebase timestamps
async function extractReadingsWithRealTimestamps(deviceNode, tank, deviceId) {
  const readings = [];
  const now = Date.now();
  
  // Helper to recursively extract all readings with Firebase metadata
  function extractRecursive(node, path = '') {
    if (!node || typeof node !== 'object') return;
    
    // Check if this is a reading entry (has distance field)
    if (node.distance !== undefined || node.distance_meters !== undefined) {
      const distance = node.distance ?? node.distance_meters ?? node.distanceMeters;
      
      if (distance !== null && distance !== undefined) {
        // üî• TRY TO GET FIREBASE SERVER TIMESTAMP
        let realTimestamp = now; // fallback to current time
        
        // Method 1: Check for Firebase server timestamp metadata
        if (node['.sv'] === 'timestamp') {
          realTimestamp = now;
        }
        // Method 2: Check if timestamp looks like a real date (after year 2000)
        else if (node.timestamp && node.timestamp > 946684800000) {
          realTimestamp = node.timestamp;
        }
        // Method 3: Use current time minus a calculated offset
        else if (node.timestamp) {
          // Device uptime in milliseconds
          const deviceUptime = node.timestamp;
          // Estimate: data was written (now - some time ago)
          // This is a rough estimate
          realTimestamp = now - (now % 1000); // Round to nearest second
        }
        
        // Calculate water level and volume
        const waterLevel = tank.calculateWaterLevelFromDistance(distance);
        const volume = tank.calculateVolumeFromWaterLevel(waterLevel);
        
        readings.push({
          timestamp: realTimestamp,
          distance: distance,
          distance_cm: distance * 100,
          waterLevel: waterLevel,
          currentVolume: volume,
          fillPercentage: ((volume / tank.calculateMaxCapacity()) * 100).toFixed(1),
          tankId: tank.id,
          tankName: tank.name,
          deviceId: deviceId,
          usingLiveData: true,
          isDataFresh: (now - realTimestamp) < 300000, // Fresh if < 5 minutes
          path: path
        });
      }
    }
    
    // Recursively search child nodes
    Object.keys(node).forEach(key => {
      if (key.startsWith('.')) return; // Skip Firebase metadata
      const childNode = node[key];
      if (childNode && typeof childNode === 'object') {
        extractRecursive(childNode, `${path}/${key}`);
      }
    });
  }
  
  extractRecursive(deviceNode);
  
  // üî• CRITICAL: If we got readings, estimate real timestamps based on order
  if (readings.length > 0) {
    // Sort by device timestamp (if available)
    readings.sort((a, b) => {
      const aTime = a.timestamp;
      const bTime = b.timestamp;
      return aTime - bTime;
    });
    
    // Distribute timestamps evenly over recent period
    // Assume readings were collected over the last N hours
    const hoursOfData = 24; // Assume last 24 hours
    const timeSpan = hoursOfData * 60 * 60 * 1000;
    const startTime = now - timeSpan;
    const interval = timeSpan / readings.length;
    
    readings.forEach((reading, index) => {
      // Assign evenly distributed timestamps
      reading.timestamp = startTime + (index * interval);
      reading.estimatedTimestamp = true;
    });
    
    console.log(`‚è∞ Estimated timestamps for ${readings.length} readings over ${hoursOfData} hours`);
  }
  
  return readings;
}





   async function loadHistory() {
  const startDate = document.getElementById('historyStartDate').value;
  const endDate = document.getElementById('historyEndDate').value;
  const timeRange = document.getElementById('historyTimeRange').value;
  
  const historyContent = document.getElementById('historyContent');
  historyContent.innerHTML = `
    <div style="text-align: center; padding: 40px; color: var(--muted);">
      <i class="fas fa-spinner fa-spin" style="font-size: 32px;"></i>
      <div style="margin-top: 12px;">Fetching ALL device data from Firebase...</div>
    </div>
  `;
  
  console.log(`üîç Loading history for ${currentHistoryType}/${currentHistoryDevice}`);
  console.log(`üìÖ Date range: ${startDate || 'ALL TIME'} to ${endDate || 'NOW'}`);
  
  try {
    let allReadings = [];
    
    // üî• STEP 1: Get the current device/tank being viewed
    const device = currentHistoryType === 'tanks' ? 
      tanks.find(t => t.id === currentHistoryDevice) : 
      valves.find(v => v.id === currentHistoryDevice);
    
    if (!device) {
      throw new Error('Device not found');
    }
    
    // üî• STEP 2: Fetch ALL device data directly from Firebase
    console.log('üì° Fetching ALL device data from Firebase...');
    const allDeviceData = await FirebaseService.fetchAllDeviceData();
    
    if (Object.keys(allDeviceData).length === 0) {
      throw new Error('No device data found in Firebase');
    }
    
    // üî• STEP 3: Extract readings from the linked device
    if (currentHistoryType === 'tanks' && device.deviceId) {
      const targetDeviceId = device.deviceId.toUpperCase();
      console.log(`üéØ Looking for device: ${targetDeviceId}`);
      
      // üî• CRITICAL: Get Firebase server timestamps for each reading
      let deviceNodePath = null;
      let rawDeviceNode = null;
      
      // Check root level
      for (const [deviceId, deviceNode] of Object.entries(allDeviceData)) {
        if (deviceId.toUpperCase() === targetDeviceId) {
          console.log(`‚úÖ Found device at root: ${deviceId}`);
          deviceNodePath = `/${deviceId}`;
          rawDeviceNode = deviceNode;
          break;
        }
      }
      
      // Also check /ultrasonic path
      if (!rawDeviceNode && allDeviceData.ultrasonic) {
        for (const [deviceId, deviceNode] of Object.entries(allDeviceData.ultrasonic)) {
          if (deviceId.toUpperCase() === targetDeviceId) {
            console.log(`‚úÖ Found device in ultrasonic path: ${deviceId}`);
            deviceNodePath = `/ultrasonic/${deviceId}`;
            rawDeviceNode = deviceNode;
            break;
          }
        }
      }
      
      if (rawDeviceNode) {
        // üî• Extract readings with FIREBASE SERVER TIMESTAMPS
        allReadings = await extractReadingsWithRealTimestamps(rawDeviceNode, device, targetDeviceId);
        console.log(`üìä Extracted ${allReadings.length} readings with real timestamps`);
      }
    }
    
    // üî• STEP 4: Also get analytics history (for comparison)
    const analyticsHistory = await HistoryService.getHistory(
      currentHistoryDevice, 
      currentHistoryType,
      startDate && startDate.trim() ? startDate : null,
      endDate && endDate.trim() ? endDate : null
    );
    
    console.log(`üìä Found ${allReadings.length} device readings`);
    console.log(`üìä Found ${analyticsHistory.length} analytics entries`);
    
    // üî• STEP 5: Merge device readings with analytics history
    const mergedData = [...allReadings];
    
    // Add analytics entries that don't have corresponding device readings
    analyticsHistory.forEach(entry => {
      const hasDeviceReading = allReadings.some(r => 
        Math.abs(r.timestamp - entry.timestamp) < 5000 // Within 5 seconds
      );
      
      if (!hasDeviceReading) {
        mergedData.push(entry);
      }
    });
    
    // Sort by timestamp (newest first)
    mergedData.sort((a, b) => b.timestamp - a.timestamp);
    
    console.log(`üìä Total merged entries: ${mergedData.length}`);
    
    // üî• STEP 6: Apply date filters
    let filteredData = mergedData;
    
    if (startDate) {
      const startTime = new Date(startDate).getTime();
      filteredData = filteredData.filter(r => r.timestamp >= startTime);
      console.log(`üìÖ After start date filter (${startDate}): ${filteredData.length} entries`);
    }
    
    if (endDate) {
      const endTime = new Date(endDate).setHours(23, 59, 59, 999);
      filteredData = filteredData.filter(r => r.timestamp <= endTime);
      console.log(`üìÖ After end date filter (${endDate}): ${filteredData.length} entries`);
    }
    
    // Apply time range filter
    if (timeRange) {
      const [startHour, endHour] = timeRange.split('-').map(Number);
      filteredData = filteredData.filter(r => {
        const hour = new Date(r.timestamp).getHours();
        return hour >= startHour && hour < endHour;
      });
      console.log(`‚è∞ After time range filter: ${filteredData.length} entries`);
    }
    
    console.log(`üìä Final filtered entries: ${filteredData.length}`);
    
    // Show timestamp samples for debugging
    if (filteredData.length > 0) {
      console.log('üïí Sample timestamps:');
      console.log('   First:', new Date(filteredData[0].timestamp).toLocaleString());
      console.log('   Last:', new Date(filteredData[filteredData.length - 1].timestamp).toLocaleString());
    }
    
    currentHistoryData = filteredData;
    
    // üî• STEP 7: Render the data
    renderHistory(currentHistoryData);
    
    // Show success message
    if (currentHistoryData.length > 0) {
      toast(`‚úÖ Loaded ${currentHistoryData.length} historical entries`);
    } else {
      toast('‚ÑπÔ∏è No data found for selected date range');
    }
    
  } catch (error) {
    console.error('‚ùå Error loading history:', error);
    historyContent.innerHTML = `
      <div style="text-align: center; padding: 40px; color: var(--danger);">
        <i class="fas fa-exclamation-triangle" style="font-size: 32px;"></i>
        <div style="margin-top: 12px; font-weight: 600;">Error Loading History</div>
        <div style="font-size: 12px; margin-top: 8px; color: var(--muted);">${error.message}</div>
        <button class="btn primary" onclick="loadHistory()" style="margin-top: 16px;">
          <i class="fas fa-redo"></i> Retry
        </button>
      </div>
    `;
    toast('‚ùå Error loading history - check console');
  }
}

    function renderHistory(history) {
  const historyContent = document.getElementById('historyContent');
  
  // Helper function for safe number formatting
  const safeNumber = (value, decimals = 0) => {
    if (value === undefined || value === null || isNaN(value) || !isFinite(value)) {
      return '-';
    }
    return Number(value).toFixed(decimals);
  };
  
  if(history.length === 0) {
    historyContent.innerHTML = `
      <div style="text-align: center; padding: 40px; color: var(--muted);">
        <i class="fas fa-inbox" style="font-size: 32px;"></i>
        <div style="margin-top: 12px;">No history data available for this date range</div>
      </div>
    `;
    return;
  }
  
  
  let tableHTML = ''; // IMPORTANT: Initialize variable
  
  if(currentHistoryType === 'tanks') {
  // Check if we have device readings (distance-based) or tank analytics
  const hasDeviceReadings = history.some(h => h.distance !== undefined);
  const hasTankAnalytics = history.some(h => h.currentVolume !== undefined);
  const hasETAData = history.some(h => h.etaStatus !== undefined);
  
  if (hasDeviceReadings && !hasTankAnalytics) {
    // Show device readings table with calculated metrics
    const hasCalculatedMetrics = history.some(h => h.waterLevel !== undefined || h.currentVolume !== undefined);
    
    tableHTML = `
      <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
        <thead>
          <tr style="background: #fafbfc; border-bottom: 2px solid var(--line);">
            <th style="padding: 12px; text-align: left; font-weight: 700;">Date</th>
            <th style="padding: 12px; text-align: left; font-weight: 700;">Time</th>
            <th style="padding: 12px; text-align: center;">Distance (m)</th>
            <th style="padding: 12px; text-align: center;">Distance (cm)</th>
            ${hasCalculatedMetrics ? '<th style="padding: 12px; text-align: center;">Water Level (m)</th>' : ''}
            ${hasCalculatedMetrics ? '<th style="padding: 12px; text-align: center;">Volume (L)</th>' : ''}
          </tr>
        </thead>
        <tbody>
          ${history.map((h, idx) => {
            const dateObj = new Date(h.timestamp);
            const dateStr = dateObj.toLocaleDateString('en-IN');
            const timeStr = dateObj.toLocaleTimeString('en-IN');
            
            return `
            <tr style="border-bottom: 1px solid #f2f4f7; ${idx % 2 === 0 ? 'background: #fafbfc;' : ''}">
              <td style="padding: 10px; white-space: nowrap; font-weight: 600;">${dateStr}</td>
              <td style="padding: 10px; white-space: nowrap;">${timeStr}</td>
              <td style="padding: 10px; text-align: center; font-weight: 600; color: #0277bd;">
                ${safeNumber(h.distance, 3)}
              </td>
              <td style="padding: 10px; text-align: center; font-weight: 600; color: #0277bd;">
                ${safeNumber(h.distance_cm, 1)}
              </td>
              ${hasCalculatedMetrics ? `
              <td style="padding: 10px; text-align: center; font-weight: 600; color: #4caf50;">
                ${safeNumber(h.waterLevel, 2)}
              </td>
              <td style="padding: 10px; text-align: center; font-weight: 700; color: #6a1b9a;">
                ${safeNumber(h.currentVolume, 0)}
              </td>
              ` : ''}
            </tr>
          `;
          }).join('')}
        </tbody>
      </table>
    `;
  } else {
    // Show full tank analytics table with ETA data
    tableHTML = `
      <div style="margin-bottom: 16px; padding: 12px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196f3;">
        <div style="font-weight: 700; margin-bottom: 4px; color: #1565c0;">
          <i class="fas fa-info-circle"></i> Historical Tank Analytics
        </div>
        <div style="font-size: 12px; color: #424242;">
          Showing ${history.length} historical entries with water level, volume, flow rate, and ETA calculations
        </div>
      </div>
      
      <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
        <thead>
          <tr style="background: #fafbfc; border-bottom: 2px solid var(--line);">
            <th style="padding: 12px; text-align: left; font-weight: 700;">Date</th>
            <th style="padding: 12px; text-align: left; font-weight: 700;">Time</th>
            ${hasDeviceReadings ? '<th style="padding: 12px; text-align: center;">Distance (m)</th>' : ''}
            <th style="padding: 12px; text-align: center;">Water Level (m)</th>
            <th style="padding: 12px; text-align: center;">Volume (L)</th>
            <th style="padding: 12px; text-align: center;">Fill %</th>
            ${hasETAData ? '<th style="padding: 12px; text-align: center;">ETA Status</th>' : ''}
            ${hasETAData ? '<th style="padding: 12px; text-align: center;">Time to Empty</th>' : ''}
            <th style="padding: 12px; text-align: center;">Flow (L/min)</th>
            <th style="padding: 12px; text-align: center;">Households</th>
            <th style="padding: 12px; text-align: left; min-width: 200px;">Changes</th>
          </tr>
        </thead>
        <tbody>
          ${history.map((h, idx) => {
            const dateObj = new Date(h.timestamp);
            const dateStr = dateObj.toLocaleDateString('en-IN');
            const timeStr = dateObj.toLocaleTimeString('en-IN');
            
            // ETA status badge
            let etaStatusBadge = '‚Äî';
            if (h.etaStatus) {
              const statusColors = {
                'critical': '#f44336',
                'warning': '#ff9800',
                'good': '#4caf50',
                'no_flow': '#999'
              };
              const statusLabels = {
                'critical': 'üî¥ CRITICAL',
                'warning': '‚ö†Ô∏è WARNING',
                'good': '‚úÖ GOOD',
                'no_flow': '‚è∏Ô∏è NO FLOW'
              };
              const statusColor = statusColors[h.etaStatus] || '#999';
              const statusLabel = statusLabels[h.etaStatus] || h.etaStatus.toUpperCase();
              etaStatusBadge = `<span style="background: ${statusColor}; color: white; padding: 4px 8px; border-radius: 6px; font-size: 11px; font-weight: 700; white-space: nowrap;">${statusLabel}</span>`;
            }
            
            // Fill percentage color
            const fillPercent = parseFloat(h.fillPercentage) || 0;
            const fillColor = fillPercent > 70 ? '#4caf50' : fillPercent > 30 ? '#ff9800' : '#f44336';
            
            // Flow rate color
            const flowRate = parseFloat(h.mainFlowRate) || 0;
            const flowColor = flowRate > 100 ? '#f44336' : flowRate > 0 ? '#4caf50' : '#999';
            
            // Data quality indicator
            const dataQualityIcon = h.usingLiveData 
              ? (h.isDataFresh ? '<span title="Live sensor data (fresh)">üì°</span>' : '<span title="Live sensor data (stale)">üì°‚ö†Ô∏è</span>')
              : '<span title="Stored data">üíæ</span>';
            
            return `
            <tr style="border-bottom: 1px solid #f2f4f7; ${idx % 2 === 0 ? 'background: #fafbfc;' : ''}">
              <td style="padding: 10px; white-space: nowrap; font-weight: 600;">${dateStr}</td>
              <td style="padding: 10px; white-space: nowrap;">${timeStr}</td>
              ${hasDeviceReadings ? `<td style="padding: 10px; text-align: center; font-weight: 600; color: #0277bd;">${safeNumber(h.distance, 3)}</td>` : ''}
              <td style="padding: 10px; text-align: center; font-weight: 600; color: #4caf50;">
                ${safeNumber(h.waterLevel, 2)} ${dataQualityIcon}
              </td>
              <td style="padding: 10px; text-align: center; font-weight: 600;">
                ${safeNumber(h.currentVolume, 0)} L
              </td>
              <td style="padding: 10px; text-align: center; font-weight: 700; color: ${fillColor};">
                ${safeNumber(h.fillPercentage, 1)}%
              </td>
              ${hasETAData ? `<td style="padding: 10px; text-align: center;">${etaStatusBadge}</td>` : ''}
              ${hasETAData ? `
                <td style="padding: 10px; text-align: center; font-weight: 600; color: ${h.etaStatus === 'critical' ? '#f44336' : h.etaStatus === 'warning' ? '#ff9800' : '#4caf50'};">
                  ${h.currentTimeFormatted || '‚Äî'}
                  ${h.currentTimeMinutes ? `<div style="font-size: 10px; color: #666; font-weight: 400;">(${safeNumber(h.currentTimeMinutes, 1)} min)</div>` : ''}
                </td>
              ` : ''}
              <td style="padding: 10px; text-align: center; font-weight: 600; color: ${flowColor};">
                ${safeNumber(h.mainFlowRate, 2)}
              </td>
              <td style="padding: 10px; text-align: center; font-weight: 700; color: #6a1b9a;">
                ${h.householdSupply || 0}
                ${h.totalHouseholds ? `<div style="font-size: 10px; color: #666; font-weight: 400;">/ ${h.totalHouseholds}</div>` : ''}
              </td>
              <td style="padding: 10px; font-size: 11px; color: #666;">
                ${h.changes || 'No changes'}
              </td>
            </tr>
          `;
          }).join('')}
        </tbody>
      </table>
      
      ${hasETAData ? `
        <div style="margin-top: 16px; padding: 12px; background: #f8f9fa; border-radius: 8px; font-size: 12px; color: #666;">
          <div style="font-weight: 700; margin-bottom: 8px; color: #333;">
            <i class="fas fa-chart-line"></i> Legend
          </div>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px;">
            <div><span style="background: #4caf50; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 700;">‚úÖ GOOD</span> - Normal operation, sufficient water</div>
            <div><span style="background: #ff9800; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 700;">‚ö†Ô∏è WARNING</span> - Low water level (&lt;4 hours remaining)</div>
            <div><span style="background: #f44336; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 700;">üî¥ CRITICAL</span> - Very low water (&lt;1 hour remaining)</div>
            <div><span style="background: #999; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 700;">‚è∏Ô∏è NO FLOW</span> - All valves closed, no outflow</div>
            <div>üì° = Live sensor data</div>
            <div>üíæ = Stored data</div>
            <div>üì°‚ö†Ô∏è = Live data (stale)</div>
          </div>
        </div>
      ` : ''}
    `;
  }
} else if(currentHistoryType === 'valves') {
    tableHTML = `
      <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
        <thead>
          <tr style="background: #fafbfc; border-bottom: 2px solid var(--line);">
            <th style="padding: 12px; text-align: left; font-weight: 700;">Date & Time</th>
            <th style="padding: 12px; text-align: center;">State</th>
            <th style="padding: 12px; text-align: center;">Supply Flow</th>
            <th style="padding: 12px; text-align: center;">Avg/HH</th>
            <th style="padding: 12px; text-align: center;">Served</th>
            <th style="padding: 12px; text-align: left; min-width: 200px;">Changes</th>
          </tr>
        </thead>
        <tbody>
          ${history.map((h, idx) => `
            <tr style="border-bottom: 1px solid #f2f4f7; ${idx % 2 === 0 ? 'background: #fafbfc;' : ''}">
              <td style="padding: 10px; white-space: nowrap;">${new Date(h.timestamp).toLocaleString()}</td>
              <td style="padding: 10px; text-align: center;">
                <span style="padding: 4px 8px; border-radius: 6px; background: ${h.valveState === 'open' ? '#e9f7ee' : '#fdeaea'}; color: ${h.valveState === 'open' ? 'var(--success)' : 'var(--danger)'}; font-weight: 600; font-size: 11px;">
                  ${(h.valveState || 'unknown').toUpperCase()}
                </span>
              </td>
              <td style="padding: 10px; text-align: center; font-weight: 600; color: ${(h.supplyFlow || 0) > 0 ? '#4caf50' : '#999'};">
                ${h.supplyFlow ? h.supplyFlow.toFixed(0) : '0'} L/min
              </td>
              <td style="padding: 10px; text-align: center; font-weight: 600;">
                ${h.avgSupplyPerHousehold ? h.avgSupplyPerHousehold.toFixed(2) : '0'} L/min
              </td>
              <td style="padding: 10px; text-align: center;">
                <span style="padding: 4px 8px; border-radius: 6px; background: ${(h.householdsServed || 0) > 0 ? '#e9f7ee' : '#fdeaea'}; color: ${(h.householdsServed || 0) > 0 ? 'var(--success)' : 'var(--danger)'}; font-weight: 600; font-size: 11px;">
                  ${h.householdsServed || 0} HH
                </span>
              </td>
              <td style="padding: 10px; font-size: 11px; color: #666;">
                ${h.changes || 'No changes recorded'}
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
  } else {
    // Fallback for unknown type
    tableHTML = `
      <div style="text-align: center; padding: 40px; color: var(--muted);">
        <i class="fas fa-exclamation-triangle" style="font-size: 32px;"></i>
        <div style="margin-top: 12px;">Unknown history type</div>
      </div>
    `;
  }
  
  historyContent.innerHTML = tableHTML;
}


// Function to manually sync all device data to history with calculated metrics
// üî• FIXED: Sync ALL device data to history with proper fetching
async function syncAllDeviceDataToHistory() {
  console.log('üîÑ Starting FULL sync of all device data to history...');
  toast('üîÑ Fetching all device data from Firebase...');
  
  try {
    // üî• STEP 1: Fetch ALL device data directly from Firebase
    console.log('üì° Fetching all device data from Firebase...');
    const allDeviceData = await FirebaseService.fetchAllDeviceData();
    
    if (Object.keys(allDeviceData).length === 0) {
      console.log('üì≠ No device data found in Firebase');
      toast('‚ö†Ô∏è No device data found in Firebase');
      return;
    }
    
    console.log(`üì¶ Found ${Object.keys(allDeviceData).length} device(s) in Firebase`);
    toast(`üì¶ Found ${Object.keys(allDeviceData).length} devices, extracting readings...`);
    
    const skipPaths = ['tanks', 'valves', 'pipelines', 'analytics', 'ultrasonic', 'history'];
    let totalReadings = 0;
    let totalSynced = 0;
    let processedDevices = 0;
    
    // üî• STEP 2: Process EACH device and extract ALL readings
    for (const deviceId of Object.keys(allDeviceData)) {
      if (skipPaths.includes(deviceId)) continue;
      
      const deviceNode = allDeviceData[deviceId];
      if (!deviceNode || typeof deviceNode !== 'object') continue;
      
      // üî• CRITICAL: Extract ALL readings from this device node
      console.log(`üîç Extracting readings from device: ${deviceId}`);
      const allReadings = FirebaseService.extractAllReadings(deviceNode);
      
      console.log(`üìä Device ${deviceId}: Found ${allReadings.length} readings`);
      totalReadings += allReadings.length;
      
      if (allReadings.length > 0) {
        // Find which tank is linked to this device
        const linkedTank = tanks.find(t => t.deviceId && t.deviceId.toUpperCase() === deviceId.toUpperCase());
        
        if (linkedTank) {
          processedDevices++;
          console.log(`üîó Device ${deviceId} ‚Üí Tank ${linkedTank.id} (${linkedTank.name})`);
          console.log(`   Tank dimensions: ${linkedTank.shape}, Height: ${linkedTank.height}m, Sensor: ${linkedTank.sensorHeight || linkedTank.height}m`);
          
          toast(`üîÑ Syncing ${allReadings.length} readings for ${linkedTank.name}...`);
          
          // üî• STEP 3: Sync readings to history WITH tank for calculations
          const result = await HistoryService.syncDeviceReadingsToHistory(
            linkedTank.id, 
            'tanks', 
            allReadings, 
            linkedTank
          );
          
          totalSynced += result.synced || 0;
          
          console.log(`‚úÖ Device ${deviceId}: Synced ${result.synced} new, skipped ${result.skipped} duplicates`);
          
          // Show progress
          toast(`‚úÖ ${linkedTank.name}: ${result.synced} synced, ${result.skipped} skipped`);
        } else {
          console.log(`‚ö†Ô∏è Device ${deviceId} is not linked to any tank`);
        }
      } else {
        console.log(`üì≠ Device ${deviceId}: No readings found`);
      }
      
      // Small delay between devices to prevent blocking
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    console.log(`\nüìä SYNC SUMMARY:`);
    console.log(`   Total Devices Processed: ${processedDevices}`);
    console.log(`   Total Readings Found: ${totalReadings}`);
    console.log(`   Total NEW Readings Synced: ${totalSynced}`);
    console.log(`   Total Duplicates Skipped: ${totalReadings - totalSynced}`);
    
    if (totalSynced > 0) {
      toast(`‚úÖ Sync complete! ${totalSynced} new readings synced to history`);
      
      // üî• STEP 4: Reload history if modal is open
      if (currentHistoryDevice && currentHistoryType) {
        console.log('üîÑ Reloading history modal...');
        setTimeout(async () => {
          await loadHistory();
          toast('‚úÖ History refreshed with new data!');
        }, 1000);
      }
    } else if (totalReadings > 0) {
      toast('‚úÖ All data already synced - no new readings found');
    } else {
      toast('‚ö†Ô∏è No device readings found to sync');
    }
    
  } catch (error) {
    console.error('‚ùå Error syncing device data:', error);
    toast('‚ùå Error syncing device data - check console');
  }
}

// Make it available globally for console access
window.syncAllDeviceDataToHistory = syncAllDeviceDataToHistory;








// Bind the sync button
document.addEventListener('DOMContentLoaded', () => {
  const syncBtn = document.getElementById('syncHistoryBtn');
  if (syncBtn) {
    syncBtn.addEventListener('click', async () => {
      syncBtn.disabled = true;
      syncBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Syncing...';
      
      await syncAllDeviceDataToHistory();
      
      syncBtn.disabled = false;
      syncBtn.innerHTML = '<i class="fas fa-sync"></i> Sync All Devices';
    });
  }
});

// TEMPORARY DEBUG FUNCTION - Remove after testing
async function debugHistory() {
  console.log('üîç Debug: Current History Device:', currentHistoryDevice);
  console.log('üîç Debug: Current History Type:', currentHistoryType);
  console.log('üîç Debug: Current History Data:', currentHistoryData);
  
  if (currentHistoryDevice && currentHistoryType) {
    const testData = await HistoryService.getHistory(
      currentHistoryDevice,
      currentHistoryType,
      null,
      null
    );
    console.log('üîç Debug: Fetched History from Firebase:', testData);
  }
}

    function exportCurrentHistory() {
      if(!currentHistoryDevice || !currentHistoryData) return;
      
      const device = currentHistoryType === 'tanks' ? 
        tanks.find(t => t.id === currentHistoryDevice) : 
        valves.find(v => v.id === currentHistoryDevice);
      
      if(!device) return;
      
      HistoryService.exportToCSV(currentHistoryData, device.name, currentHistoryType);
    }

    // ==================== HELPER FUNCTIONS ====================

// Convert ESP32 millis timestamp to real datetime
function convertDeviceTimestamp(deviceMillis) {
  if (!deviceMillis) return null;
  
  // Device sends millis since boot, we need to calculate actual time
  // Assume we store the server time when device first connected
  const now = Date.now();
  const estimatedBootTime = now - deviceMillis;
  return new Date(estimatedBootTime + deviceMillis);
}

// Get real timestamp from device data
function getRealTimestamp(deviceTelemetry) {
  if (!deviceTelemetry) return null;
  
  const deviceMillis = deviceTelemetry.timestamp;
  if (!deviceMillis) return null;
  
  // Calculate real time: current time - (device uptime)
  const now = Date.now();
  const deviceUptime = deviceMillis;
  const estimatedRealTime = now - (Date.now() - deviceUptime);
  
  return new Date(estimatedRealTime);
}

// Calculate ETA for tank depletion with proper datetime
function calculateTankETAWithTime(tank, currentFlow) {
  const currentVolume = tank.calculateCurrentVolume();
  const maxCapacity = tank.calculateMaxCapacity();
  const fillPercent = (currentVolume / maxCapacity) * 100;
  
  let status = 'good';
  let statusColor = '#4caf50';
  let timeToEmpty = 0;
  let etaDate = null;
  let etaFormatted = '‚Äî';
  
  if (currentFlow > 0) {
    timeToEmpty = currentVolume / currentFlow; // minutes
    const now = new Date();
    etaDate = new Date(now.getTime() + timeToEmpty * 60000);
    
    // Format ETA
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    if (etaDate.toDateString() === today.toDateString()) {
      etaFormatted = `Today at ${etaDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}`;
    } else if (etaDate.toDateString() === tomorrow.toDateString()) {
      etaFormatted = `Tomorrow at ${etaDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}`;
    } else {
      etaFormatted = etaDate.toLocaleString('en-US', { 
        month: 'short', 
        day: 'numeric', 
        hour: '2-digit', 
        minute: '2-digit' 
      });
    }
    
    // Status logic
    if (timeToEmpty < 60) { // Less than 1 hour
      status = 'critical';
      statusColor = '#f44336';
    } else if (timeToEmpty < 240) { // Less than 4 hours
      status = 'warning';
      statusColor = '#ff9800';
    }
  } else {
    status = 'no_flow';
    statusColor = '#2196f3';
  }
  
  return {
    status,
    statusColor,
    currentVolume,
    maxCapacity,
    fillPercent,
    currentFlow,
    timeToEmpty,
    etaDate,
    etaFormatted,
    timeFormatted: formatTime(timeToEmpty)
  };
}

// Format time in human readable format
function formatTime(minutes) {
  if (minutes === 0) return '‚Äî';
  
  const hours = Math.floor(minutes / 60);
  const mins = Math.floor(minutes % 60);
  const days = Math.floor(hours / 24);
  const remainingHours = hours % 24;
  
  if (days > 0) {
    return `${days}d ${remainingHours}h ${mins}m`;
  } else if (hours > 0) {
    return `${hours}h ${mins}m`;
  } else {
    return `${mins}m`;
  }
}

// Recursive function to get all sub-valves (multi-level)
function getAllSubValvesRecursive(mainValveId, allValves) {
  const directSubs = allValves.filter(v => v.parentValveId === mainValveId);
  let allSubs = [...directSubs];
  
  // Recursively get sub-valves of sub-valves
  directSubs.forEach(subValve => {
    const nestedSubs = getAllSubValvesRecursive(subValve.id, allValves);
    allSubs = [...allSubs, ...nestedSubs];
  });
  
  return allSubs;
}

// Calculate total households including all nested sub-valves
function calculateTotalHouseholds(valve, allValves) {
  let total = valve.households || 0;
  
  const allSubValves = getAllSubValvesRecursive(valve.id, allValves);
  allSubValves.forEach(sv => {
    total += sv.households || 0;
  });
  
  return total;
}

// Calculate currently served households (only open valves)
function calculateServedHouseholds(valve, allValves) {
  let served = 0;
  
  // If main valve is closed, nobody gets water
  if (valve.active) return 0;
  
  // Add direct households if valve is open
  served += valve.households || 0;
  
  // Recursively check sub-valves
  const directSubs = allValves.filter(v => v.parentValveId === valve.id);
  directSubs.forEach(subValve => {
    if (!subValve.active) {
      served += calculateServedHouseholds(subValve, allValves);
    }
  });
  
  return served;
}

// Search valves by ID or name
function searchValves(query, allValves) {
  if (!query) return [];
  
  const lowerQuery = query.toLowerCase();
  return allValves.filter(v => 
    v.id.toLowerCase().includes(lowerQuery) || 
    v.name.toLowerCase().includes(lowerQuery)
  );
}






// ==================== REAL-TIME TANK DATA GETTER ====================
function getLiveTankData(tank) {
  // Get real-time telemetry from device with fallback chain
  const analyticsTank = analyticsState?.tanks?.[tank.id] || null;
  const deviceTelemetry = analyticsTank?.device || resolveDeviceTelemetry(tank);
  
  // Get real distance from device (ESP32 sends "distance" field)
  const telemetryDistance = deviceTelemetry?.distance ?? 
                           deviceTelemetry?.distance_meters ?? 
                           deviceTelemetry?.distanceMeters ?? 
                           null;
  
  // Calculate CURRENT water level from LIVE distance
  let currentWaterLevel = tank.waterLevel; // fallback to stored value
  let usingLiveData = false;
  
  if (telemetryDistance !== null && telemetryDistance !== undefined && tank.deviceId) {
    currentWaterLevel = tank.calculateWaterLevelFromDistance(telemetryDistance);
    usingLiveData = true;
    console.log(`üìä Using LIVE water level: ${currentWaterLevel.toFixed(2)}m (from distance: ${telemetryDistance.toFixed(3)}m)`);
  } else {
    console.log(`‚ö†Ô∏è Using STORED water level: ${currentWaterLevel.toFixed(2)}m (no live telemetry)`);
  }
  
  // CRITICAL: Calculate volumes using CURRENT water level
  let currentVolume = 0;
  let maxCapacity = 0;
  
  if (tank.shape === 'cylinder' && tank.diameter) {
    const radius = tank.diameter / 2;
    currentVolume = Math.PI * Math.pow(radius, 2) * currentWaterLevel * 1000; // m¬≥ to liters
    maxCapacity = Math.PI * Math.pow(radius, 2) * tank.height * 1000;
  } else if (tank.shape === 'cuboid' && tank.length && tank.breadth) {
    currentVolume = tank.length * tank.breadth * currentWaterLevel * 1000; // m¬≥ to liters
    maxCapacity = tank.length * tank.breadth * tank.height * 1000;
  } else {
    // Fallback calculation
    maxCapacity = tank.capacity || 20000;
    const maxHeight = tank.height || 10;
    currentVolume = (currentWaterLevel / maxHeight) * maxCapacity;
  }
  
  const fillPercentage = maxCapacity > 0 ? (currentVolume / maxCapacity) * 100 : 0;
  
  // Format timestamp with age indicator
  let deviceTimestamp = '‚Äî';
  let deviceTimestampRaw = null;
  let isDataFresh = false;
  
  if (deviceTelemetry?.timestamp) {
    const now = Date.now();
    const deviceMillis = deviceTelemetry.timestamp;
    
    // Handle different timestamp formats
    let realTime;
    if (deviceMillis > 946684800000) {
      // Already in milliseconds (after year 2000)
      realTime = new Date(deviceMillis);
    } else {
      // Relative timestamp - estimate real time
      const estimatedBootTime = now - deviceMillis;
      realTime = new Date(estimatedBootTime + deviceMillis);
    }
    
    deviceTimestampRaw = realTime;
    deviceTimestamp = realTime.toLocaleString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: true
    });
    
    const secondsAgo = Math.floor((now - realTime.getTime()) / 1000);
    isDataFresh = secondsAgo < 300; // Fresh if less than 5 minutes old
    
    if (secondsAgo < 60) {
      deviceTimestamp += ` (${secondsAgo}s ago)`;
    } else if (secondsAgo < 3600) {
      deviceTimestamp += ` (${Math.floor(secondsAgo / 60)}m ago)`;
    } else {
      deviceTimestamp += ` (${Math.floor(secondsAgo / 3600)}h ago)`;
    }
  }
  
  console.log(`üíß Live Tank Data Summary:
    Tank: ${tank.name}
    Using Live Data: ${usingLiveData}
    Water Level: ${currentWaterLevel.toFixed(2)}m
    Current Volume: ${Math.round(currentVolume).toLocaleString()}L
    Fill: ${fillPercentage.toFixed(1)}%
    Data Freshness: ${isDataFresh ? 'FRESH' : 'STALE'}`);
  
  return {
    // Live sensor data
    telemetryDistance: telemetryDistance,
    distanceCm: telemetryDistance ? (telemetryDistance * 100).toFixed(1) : null,
    currentWaterLevel: currentWaterLevel,
    
    // Calculated volumes (in liters)
    currentVolume: Math.round(currentVolume),
    maxCapacity: Math.round(maxCapacity),
    fillPercentage: fillPercentage.toFixed(1),
    
    // Device info
    deviceTelemetry: deviceTelemetry,
    deviceTimestamp: deviceTimestamp,
    deviceTimestampRaw: deviceTimestampRaw,
    hasLiveData: telemetryDistance !== null,
    isDataFresh: isDataFresh,
    usingLiveData: usingLiveData
  };
}







// ==================== ETA CACHING TO PREVENT RECALCULATION ====================
let etaCache = new Map();
let etaCacheTimeout = null;

function clearETACache() {
  etaCache.clear();
}

function getCachedETA(tankId) {
  return etaCache.get(tankId);
}

function cacheETA(tankId, etaData) {
  etaCache.set(tankId, etaData);
  
  // Clear cache after 30 seconds
  clearTimeout(etaCacheTimeout);
  etaCacheTimeout = setTimeout(clearETACache, 30000);
}



// ==================== MAIN SHOWDEVICE FUNCTION ====================

async function showDevice(device, type) {
  document.getElementById('supplyDashboard').classList.add('shifted');

  const sidebar = document.getElementById('sidebar');
  const body = document.getElementById('sidebarBody');
  currentSidebarDeviceId = device?.id || null;
  currentSidebarDeviceType = type || null;
  
  if(type === 'tank') {
  const info = device.info();
  const connectedPipelines = findConnectedPipelines(device);
  
  // ‚úÖ USE NEW CENTRALIZED LIVE DATA GETTER
  const liveData = getLiveTankData(device);
  
  // Calculate ETA using LIVE water level
// Use cached ETA to avoid recalculation
let etaData = getCachedETA(device.id);
if (!etaData) {
  etaData = calculateTankETA(device);
  cacheETA(device.id, etaData);
}  
  // Calculate total households served
  let totalHouseholdsServed = 0;
  if (device.connectedMainValves && device.connectedMainValves.length > 0) {
    const connectedValves = valves.filter(v => 
      device.connectedMainValves.includes(v.id) && v.category === 'main'
    );
    connectedValves.forEach(valve => {
      totalHouseholdsServed += calculateServedHouseholds(valve, valves);
    });
  }
  
  setText('sidebarTitle', `üèóÔ∏è ${device.name}`);
  body.innerHTML = `
    <div class="card">
      <h4><i class="fas fa-info-circle"></i> DETAILS</h4>
      <div class="row"><span class="label">ID</span><span class="value">${info.id}</span></div>
      <div class="row"><span class="label">Type</span><span class="value">${info.type}</span></div>
      <div class="row"><span class="label">Shape</span><span class="value">${device.shape === 'cylinder' ? 'Cylinder' : 'Cuboid'}</span></div>
      <div class="row"><span class="label">Dimensions</span><span class="value">${
        device.shape === 'cylinder' 
          ? `√ò${device.diameter}m √ó H${device.height}m` 
          : `${device.length}m √ó ${device.breadth}m √ó ${device.height}m`
      }</span></div>
      <div class="row"><span class="label">Max Capacity</span><span class="value">${liveData.maxCapacity.toLocaleString()} L</span></div>
      <div class="row"><span class="label">Status</span><span class="value" style="color:var(--success)">${info.status.toUpperCase()}</span></div>
    </div>
    
    ${device.deviceId ? `
    <div class="card" style="background: linear-gradient(135deg, #0288d1 0%, #0277bd 100%); color: #fff; border: none;">
      <h4 style="color: #fff; margin: 0 0 12px 0;">
        <i class="fas fa-satellite-dish"></i> 
        LIVE DEVICE DATA
        ${liveData.hasLiveData ? '<span style="animation: pulse 2s infinite; background: #4caf50; color: white; padding: 2px 6px; border-radius: 4px; font-size: 9px; margin-left: 8px;">LIVE</span>' : ''}
      </h4>
      <div class="row" style="background: rgba(255,255,255,0.15); padding: 10px; border-radius: 8px; margin: 8px 0;">
        <span class="label" style="color: rgba(255,255,255,0.9);">Device ID</span>
        <span class="value" style="color: #fff; font-weight: 700;">${device.deviceId}</span>
      </div>
      ${liveData.hasLiveData ? `
      <div class="row" style="background: rgba(255,255,255,0.15); padding: 10px; border-radius: 8px; margin: 8px 0;">
        <span class="label" style="color: rgba(255,255,255,0.9);">üìè Distance (Sensor ‚Üí Water)</span>
        <span class="value" style="color: #fff; font-weight: 700; font-size: 18px;">${liveData.distanceCm} cm</span>
      </div>
      <div class="row" style="background: rgba(255,255,255,0.15); padding: 10px; border-radius: 8px; margin: 8px 0;">
        <span class="label" style="color: rgba(255,255,255,0.9);">üìä Calculated Water Level</span>
        <span class="value" style="color: #fff; font-weight: 700; font-size: 18px;">${liveData.currentWaterLevel.toFixed(2)} m</span>
      </div>
      <div class="row" style="background: rgba(255,255,255,0.15); padding: 10px; border-radius: 8px; margin: 8px 0;">
        <span class="label" style="color: rgba(255,255,255,0.9);">üíß Current Volume</span>
        <span class="value" style="color: #4caf50; font-weight: 700; font-size: 20px;">${liveData.currentVolume.toLocaleString()} L</span>
      </div>
      <div class="row" style="background: rgba(255,255,255,0.15); padding: 10px; border-radius: 8px; margin: 8px 0;">
        <span class="label" style="color: rgba(255,255,255,0.9);">üìà Fill Percentage</span>
        <span class="value" style="color: ${parseFloat(liveData.fillPercentage) > 70 ? '#4caf50' : parseFloat(liveData.fillPercentage) > 30 ? '#ff9800' : '#f44336'}; font-weight: 700; font-size: 18px;">${liveData.fillPercentage}%</span>
      </div>
      <div class="row" style="background: rgba(255,255,255,0.15); padding: 10px; border-radius: 8px; margin: 8px 0;">
        <span class="label" style="color: rgba(255,255,255,0.9);">Last Update</span>
        <span class="value" style="color: #fff;">${liveData.deviceTimestamp}</span>
      </div>
      ` : `
      <div class="row" style="background: rgba(255,193,7,0.2); padding: 10px; border-radius: 8px; margin: 8px 0; border: 1px solid rgba(255,193,7,0.5);">
        <span class="label" style="color: rgba(255,255,255,0.9);"><i class="fas fa-clock"></i> Status</span>
        <span class="value" style="color: #ffc107; font-weight: 600;">Waiting for device data...</span>
      </div>
      <div style="font-size: 11px; color: rgba(255,255,255,0.7); margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;">
        <i class="fas fa-info-circle"></i> Device ID "${device.deviceId}" is linked, but no telemetry data found in Firebase. 
        Ensure your ESP32 device is posting to <code>/${device.deviceId}</code>
      </div>
      `}
    </div>
    ` : `
    <div class="card" style="background: #fff3cd; border: 2px solid #ffc107;">
      <h4 style="color: #856404;"><i class="fas fa-exclamation-triangle"></i> NO DEVICE LINKED</h4>
      <p style="color: #856404; margin: 8px 0;">This tank is not connected to a device. Edit the tank to add a Device ID.</p>
      <button class="btn primary" onclick="editTank('${device.id}')" style="margin-top: 8px;">
        <i class="fas fa-link"></i> Link Device
      </button>
    </div>
    `}
    
    <div class="water-level-container">
      <h4 style="margin:0 0 12px 0;font-size:13px;font-weight:700;color:#0277bd">
        <i class="fas fa-water"></i> WATER LEVEL ${device.deviceId ? '(AUTO FROM DEVICE)' : '(MANUAL)'}
      </h4>
      <div class="water-tank-visual">
        <div class="water-fill" id="waterFill" style="height:${(liveData.currentWaterLevel / (device.sensorHeight || device.height)) * 100}%">
          ${liveData.currentWaterLevel.toFixed(2)} m (${liveData.currentVolume.toLocaleString()} L)
        </div>
      </div>
      <input type="range" class="water-level-slider" id="waterLevelSlider" 
             min="0" max="${device.height}" step="0.1" value="${liveData.currentWaterLevel}" 
             ${device.deviceId ? 'disabled title="Water level is automatically updated from device"' : ''}/>
      <div style="text-align:center;margin-top:8px;font-size:13px;color:#0277bd;font-weight:600">
        ${device.deviceId ? 'Auto-updated from device' : 'Adjust water level'}: 
        <span id="waterLevelDisplay">${liveData.currentWaterLevel.toFixed(2)} m</span>
      </div>
    </div>
    
    <div class="card" style="background: linear-gradient(135deg, ${(etaData.statusColor || '#4caf50')}15, ${(etaData.statusColor || '#4caf50')}05); border: 2px solid ${(etaData.statusColor || '#4caf50')};">
      <h4 style="color: ${etaData.statusColor || '#4caf50'};"><i class="fas fa-clock"></i> WATER DEPLETION FORECAST</h4>
      ${etaData.status === 'not_configured' ? `
        <div style="text-align: center; padding: 20px;">
          <i class="fas fa-cog" style="font-size: 32px; color: #999; margin-bottom: 8px;"></i>
          <div style="font-size: 14px; color: #666; font-weight: 600;">${etaData.message}</div>
          <button class="btn primary" onclick="editTank('${device.id}')" style="margin-top: 12px;">
            <i class="fas fa-link"></i> Connect Main Valves
          </button>
        </div>
      ` : `
        <!-- Data Quality Indicator -->
        ${liveData.usingLiveData ? `
          <div style="background: ${liveData.isDataFresh ? '#e8f5e9' : '#fff3cd'}; padding: 10px; border-radius: 8px; margin-bottom: 12px; border: 2px solid ${liveData.isDataFresh ? '#4caf50' : '#ffc107'};">
            <div style="display: flex; align-items: center; gap: 8px;">
              <i class="fas fa-${liveData.isDataFresh ? 'check-circle' : 'exclamation-triangle'}" style="color: ${liveData.isDataFresh ? '#4caf50' : '#ffc107'}; font-size: 18px;"></i>
              <div style="flex: 1;">
                <div style="font-weight: 700; font-size: 12px; color: ${liveData.isDataFresh ? '#2e7d32' : '#f57c00'};">
                  ${liveData.isDataFresh ? '‚úÖ LIVE DATA - FRESH' : '‚ö†Ô∏è LIVE DATA - STALE'}
                </div>
                <div style="font-size: 10px; color: #666;">
                  Last update: ${liveData.deviceTimestamp}
                </div>
              </div>
            </div>
          </div>
        ` : `
          <div style="background: #ffebee; padding: 10px; border-radius: 8px; margin-bottom: 12px; border: 2px solid #f44336;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <i class="fas fa-database" style="color: #f44336; font-size: 18px;"></i>
              <div style="flex: 1;">
                <div style="font-weight: 700; font-size: 12px; color: #c62828;">
                  üìä USING STORED DATA
                </div>
                <div style="font-size: 10px; color: #666;">
                  No live device telemetry available
                </div>
              </div>
            </div>
          </div>
        `}
        
        <!-- Status Banner -->
        <div class="row" style="background: rgba(255,255,255,0.5); padding: 12px; border-radius: 8px; margin: 8px 0;">
          <span class="label" style="font-weight: 700;">Status</span>
          <span class="value" style="color: ${etaData.statusColor}; font-weight: 700; text-transform: uppercase;">
            ${etaData.status === 'critical' ? 'üî¥ CRITICAL' : 
              etaData.status === 'warning' ? '‚ö†Ô∏è WARNING' : 
              etaData.status === 'no_flow' ? '‚è∏Ô∏è NO FLOW' : '‚úÖ GOOD'}
          </span>
        </div>
        
        ${etaData.statusMessage ? `
          <div style="background: rgba(255,255,255,0.3); padding: 10px; border-radius: 8px; margin: 8px 0; text-align: center;">
            <div style="font-size: 13px; font-weight: 600; color: ${etaData.statusColor};">
              ${etaData.statusMessage}
            </div>
          </div>
        ` : ''}
        
        <!-- Volume Info -->
        <div class="row" style="background: rgba(255,255,255,0.5); padding: 12px; border-radius: 8px; margin: 8px 0;">
          <span class="label" style="font-weight: 700;">Current Volume:</span>
          <span class="value" style="color: #03a9f4; font-size: 20px; font-weight: 700;">
            ${liveData.currentVolume.toLocaleString()} L
          </span>
        </div>
        
        <div class="row">
          <span class="label">Max Capacity:</span>
          <span class="value">${liveData.maxCapacity.toLocaleString()} L</span>
        </div>
        
        <div class="row">
          <span class="label">Fill Percentage:</span>
          <span class="value" style="color: ${parseFloat(liveData.fillPercentage) > 70 ? '#4caf50' : parseFloat(liveData.fillPercentage) > 30 ? '#ff9800' : '#f44336'};">
            ${liveData.fillPercentage}%
          </span>
        </div>
        
        <div class="row">
          <span class="label">Water Level:</span>
          <span class="value">${liveData.currentWaterLevel.toFixed(2)} m ${liveData.usingLiveData ? 'üì°' : 'üíæ'}</span>
        </div>
        
        <!-- Main Outflow Section -->
        <div style="background: rgba(255,255,255,0.3); padding: 12px; border-radius: 8px; margin: 12px 0;">
          <div style="font-weight: 700; margin-bottom: 10px; font-size: 12px;">
            <i class="fas fa-tint"></i> MAIN WATER OUTFLOW
          </div>
          
          <div class="row" style="margin: 4px 0;">
            <span class="label">Flow Rate</span>
            <span class="value" style="color: ${etaData.currentFlow > 0 ? '#4caf50' : '#999'}; font-weight: 700; font-size: 18px;">
              ${etaData.currentFlow.toFixed(1)} L/min
            </span>
          </div>
          
          <div class="row" style="margin: 4px 0;">
            <span class="label">Time to Empty</span>
            <span class="value" style="font-size: 16px; font-weight: 700; color: ${etaData.statusColor};">
              ${etaData.currentTimeFormatted}
            </span>
          </div>
          
          ${etaData.currentFlow > 0 ? `
            <div class="row" style="margin: 4px 0;">
              <span class="label">Empty By (ETA)</span>
              <span class="value" style="font-weight: 700; font-size: 11px;">
                ${etaData.currentETAFormatted}
              </span>
            </div>
            
            <div class="row" style="margin: 4px 0; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.3);">
              <span class="label">Time Remaining (minutes)</span>
              <span class="value" style="font-weight: 600;">${etaData.currentTimeMinutes.toFixed(1)} min</span>
            </div>
          ` : ''}
        </div>
        
        <!-- Valve Flow Breakdown -->
        ${etaData.valveDetails && etaData.valveDetails.length > 0 ? `
          <div style="background: rgba(255,255,255,0.3); padding: 12px; border-radius: 8px; margin: 12px 0;">
            <div style="font-weight: 700; margin-bottom: 10px; font-size: 12px;">
              <i class="fas fa-tachometer-alt"></i> CONNECTED VALVES (${etaData.connectedMainValves})
            </div>
            ${etaData.valveDetails.map(vd => `
              <div style="background: ${vd.isOpen ? 'rgba(76,175,80,0.1)' : 'rgba(244,67,54,0.1)'}; padding: 8px; border-radius: 6px; margin: 6px 0; border-left: 3px solid ${vd.isOpen ? '#4caf50' : '#f44336'};">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                  <div style="font-weight: 600; font-size: 12px;">${vd.name}</div>
                  <div style="font-weight: 700; color: ${vd.isOpen ? '#4caf50' : '#f44336'}; font-size: 14px;">
                    ${vd.actualFlow.toFixed(1)} L/min
                  </div>
                </div>
                <div style="font-size: 10px; color: #666;">
                  ${vd.isOpen ? '‚úÖ OPEN' : 'üî¥ CLOSED'} ‚Ä¢ ${vd.householdsServed}/${vd.households} HH served
                  ${vd.totalSubValves > 0 ? ` ‚Ä¢ ${vd.openSubValves}/${vd.totalSubValves} sub-valves open` : ''}
                </div>
              </div>
            `).join('')}
          </div>
        ` : ''}
        
        <!-- Household Supply -->
        <div class="row" style="background: rgba(255,255,255,0.3); padding: 10px; border-radius: 8px;">
          <span class="label">Households Supplied</span>
          <span class="value" style="color: #6a1b9a; font-weight: 700;">
            ${totalHouseholdsServed || 0} / ${etaData.totalHouseholdsCapacity || 0} HH
          </span>
        </div>
        
        <!-- Critical Warning -->
        ${etaData.status === 'critical' ? `
          <div style="background: #ffebee; border: 2px solid #f44336; border-radius: 8px; padding: 12px; margin-top: 12px; animation: pulse 2s infinite;">
            <div style="color: #c62828; font-weight: 700; font-size: 13px; text-align: center;">
              <i class="fas fa-exclamation-triangle"></i> CRITICAL: Tank will be empty in ${etaData.currentTimeFormatted}!
            </div>
            <div style="font-size: 11px; color: #666; text-align: center; margin-top: 6px;">
              Immediate action required to avoid water shortage
            </div>
          </div>
        ` : etaData.status === 'warning' ? `
          <div style="background: #fff3cd; border: 2px solid #ff9800; border-radius: 8px; padding: 12px; margin-top: 12px;">
            <div style="color: #f57c00; font-weight: 700; font-size: 13px; text-align: center;">
              <i class="fas fa-exclamation-circle"></i> WARNING: Low water level - ${etaData.currentTimeFormatted} remaining
            </div>
            <div style="font-size: 11px; color: #666; text-align: center; margin-top: 6px;">
              Monitor closely and prepare for refill
            </div>
          </div>
        ` : etaData.status === 'good' && etaData.currentFlow > 0 ? `
          <div style="background: #e8f5e9; border: 2px solid #4caf50; border-radius: 8px; padding: 12px; margin-top: 12px;">
            <div style="color: #2e7d32; font-weight: 700; font-size: 13px; text-align: center;">
              <i class="fas fa-check-circle"></i> GOOD: Water supply stable
            </div>
            <div style="font-size: 11px; color: #666; text-align: center; margin-top: 6px;">
              Sufficient water for ${etaData.currentTimeFormatted}
            </div>
          </div>
        ` : ''}
        
        <!-- Calculation Details (Debug Info) -->
        ${etaData.calculationDetails ? `
          <details style="margin-top: 12px; font-size: 11px; color: #666;">
            <summary style="cursor: pointer; font-weight: 600; padding: 8px; background: rgba(0,0,0,0.05); border-radius: 6px; user-select: none;">
              üìä Calculation Details (Click to expand)
            </summary>
            <div style="padding: 8px; background: #f8f9fa; border-radius: 6px; margin-top: 6px; font-family: monospace;">
              <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 12px;">
                <div style="font-weight: 600;">Tank Height:</div>
                <div>${etaData.calculationDetails.tankHeight}m</div>
                
                <div style="font-weight: 600;">Sensor Height:</div>
                <div>${etaData.calculationDetails.sensorHeight}m (from bottom)</div>
                
                <div style="font-weight: 600;">Water Level:</div>
                <div>${etaData.calculationDetails.currentWaterLevel?.toFixed(3)}m</div>
                
                <div style="font-weight: 600;">Current Volume:</div>
                <div>${Math.round(etaData.calculationDetails.currentVolume).toLocaleString()}L</div>
                
                <div style="font-weight: 600;">Total Flow Out:</div>
                <div>${etaData.calculationDetails.totalCurrentFlow?.toFixed(2)} L/min</div>
                
                <div style="font-weight: 600;">Potential Flow:</div>
                <div>${etaData.calculationDetails.totalPotentialFlow?.toFixed(2)} L/min</div>
                
                <div style="font-weight: 600;">Connected Valves:</div>
                <div>${etaData.calculationDetails.connectedValvesCount}</div>
                
                <div style="font-weight: 600;">Using Live Data:</div>
                <div>${etaData.calculationDetails.usingLiveData ? '‚úÖ Yes' : 'üíæ No'}</div>
                
                <div style="font-weight: 600;">Data Freshness:</div>
                <div>${etaData.calculationDetails.isDataFresh ? '‚úÖ Fresh' : '‚ö†Ô∏è Stale'}</div>
              </div>
            </div>
          </details>
        ` : ''}
      `}
    </div>

    <div class="card">
      <h4><i class="fas fa-map-marker-alt"></i> LOCATION</h4>
      <div class="row"><span class="label">State</span><span class="value">${info.loc.state}</span></div>
      <div class="row"><span class="label">District</span><span class="value">${info.loc.district}</span></div>
      <div class="row"><span class="label">Mandal</span><span class="value">${info.loc.mandal}</span></div>
      <div class="row"><span class="label">Habitation</span><span class="value">${info.loc.habitation}</span></div>
      <div class="row"><span class="label">Coordinates</span><span class="value">${info.loc.coords}</span></div>
      <button class="btn primary" onclick="map.setView([${device.lat},${device.lng}],18)"><i class="fas fa-crosshairs"></i> Center on Map</button>
    </div>

    <div class="card">
      <h4><i class="fas fa-valve"></i> CONNECTED MAIN VALVES CONTROL</h4>
      ${(() => {
        if (!device.connectedMainValves || device.connectedMainValves.length === 0) {
          return `
            <div style="text-align: center; padding: 20px; color: var(--muted);">
              <i class="fas fa-unlink" style="font-size: 24px; margin-bottom: 8px;"></i>
              <div style="font-size: 13px;">No main valves connected</div>
              <button class="btn primary" onclick="editTank('${device.id}')" style="margin-top: 12px;">
                <i class="fas fa-link"></i> Connect Main Valves
              </button>
            </div>
          `;
        }
        
        const connectedValves = valves.filter(v => 
          device.connectedMainValves.includes(v.id) && v.category === 'main'
        );
        
        if (connectedValves.length === 0) {
          return `
            <div style="text-align: center; padding: 20px; color: var(--muted);">
              <i class="fas fa-exclamation-triangle" style="font-size: 24px; margin-bottom: 8px;"></i>
              <div style="font-size: 13px;">Connected valves not found in system</div>
            </div>
          `;
        }
        
        let totalOutflow = 0;
        const valveControls = connectedValves.map(valve => {
          const subValves = valves.filter(v => v.category === 'sub' && v.parentValveId === valve.id);
          let valveOutflow = 0;
          
          if (!valve.active) {
            valveOutflow = valve.flowRate || 0;
            subValves.forEach(sv => {
              if (!sv.active) valveOutflow += (sv.flowRate || 0);
            });
          }
          
          totalOutflow += valveOutflow;
          
          return `
            <div style="background: ${valve.active ? '#ffebee' : '#e8f5e9'}; 
                        border: 2px solid ${valve.active ? '#f44336' : '#4caf50'}; 
                        border-radius: 10px; 
                        padding: 14px; 
                        margin-bottom: 12px;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <div style="flex: 1;">
                  <div style="font-weight: 700; font-size: 14px; color: #333;">
                    <i class="fas fa-cog"></i> ${valve.name}
                  </div>
                  <div style="font-size: 11px; color: #666; margin-top: 4px;">
                    ${valve.households} households ‚Ä¢ ${valve.mandal}
                  </div>
                </div>
                <div style="text-align: right;">
                  <div style="font-size: 18px; font-weight: 700; color: ${valve.active ? '#f44336' : '#4caf50'};">
                    ${valveOutflow.toFixed(1)} L/min
                  </div>
                  <div style="font-size: 10px; color: ${valve.active ? '#f44336' : '#4caf50'}; font-weight: 600;">
                    ${valve.active ? 'üî¥ CLOSED' : '‚úÖ OPEN'}
                  </div>
                </div>
              </div>
              
              ${subValves.length > 0 ? `
                <div style="background: rgba(255,255,255,0.5); border-radius: 6px; padding: 8px; margin-bottom: 10px;">
                  <div style="font-size: 11px; font-weight: 600; color: #666; margin-bottom: 6px;">
                    Sub-Valves (${subValves.filter(sv => !sv.active).length}/${subValves.length} open)
                  </div>
                  ${subValves.map(sv => `
                    <div style="font-size: 10px; color: #666; padding: 2px 0;">
                      <span style="color: ${sv.active ? '#f44336' : '#4caf50'};">
                        ${sv.active ? '‚óè' : '‚óã'}
                      </span>
                      ${sv.name} (${sv.households} HH, ${sv.flowRate || 0} L/min)
                    </div>
                  `).join('')}
                </div>
              ` : ''}
              
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <button class="btn success" 
                        onclick="setValveFlow('${valve.id}', false)" 
                        ${!valve.active ? 'disabled' : ''}
                        style="margin: 0; padding: 8px; font-size: 12px;">
                  <i class="fas fa-check"></i> Open
                </button>
                <button class="btn danger" 
                        onclick="setValveFlow('${valve.id}', true)" 
                        ${valve.active ? 'disabled' : ''}
                        style="margin: 0; padding: 8px; font-size: 12px;">
                  <i class="fas fa-ban"></i> Close
                </button>
              </div>
            </div>
          `;
        }).join('');
        
        return `
          <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                      color: white; 
                      border-radius: 10px; 
                      padding: 14px; 
                      margin-bottom: 16px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div>
                <div style="font-size: 12px; opacity: 0.9;">MAIN WATER OUTFLOW</div>
                <div style="font-size: 28px; font-weight: 700;">${totalOutflow.toFixed(1)} <span style="font-size: 14px;">L/min</span></div>
              </div>
              <div style="text-align: right;">
                <div style="font-size: 12px; opacity: 0.9;">Active Valves</div>
                <div style="font-size: 24px; font-weight: 700;">${connectedValves.filter(v => !v.active).length}/${connectedValves.length}</div>
              </div>
            </div>
          </div>
          ${valveControls}
        `;
      })()}
    </div>

    <div class="card">
      <h4><i class="fas fa-tools"></i> ACTIONS</h4>
      <button class="btn" onclick="editTank('${device.id}')"><i class="fas fa-pen"></i> Edit Tank</button>
      <button class="btn danger" onclick="deleteTank('${device.id}')"><i class="fas fa-trash"></i> Delete</button>
    </div>

    <div class="card">
      <h4><i class="fas fa-clock-rotate-left"></i> HISTORICAL DATA</h4>
      <button class="btn primary" onclick="openHistory('${device.id}', 'tanks')">
        <i class="fas fa-history"></i> View History
      </button>
    </div>
  `;
  
  // Water level slider event (only if manual mode)
  if (!device.deviceId) {
    const slider = document.getElementById('waterLevelSlider');
    const fill = document.getElementById('waterFill');
    const display = document.getElementById('waterLevelDisplay');
    slider.addEventListener('input', async (e) => {
      const level = parseFloat(e.target.value);
      fill.style.height = `${(level / device.height) * 100}%`;
      
      // Calculate volume for this level
      device.waterLevel = level;
      const volume = Math.round(device.calculateCurrentVolume());
      
      fill.textContent = `${level.toFixed(2)} m (${volume.toLocaleString()} L)`;
      display.textContent = `${level.toFixed(2)} m`;
      
      await FirebaseService.saveTank(device);
    });
  }
} else {
        // VALVE SIDEBAR
        const info = device.info();
        const affectedPipelines = findAffectedPipelines(device);
        const { stats } = calculateHouseholdStats();
        const supplies = calculateSupplyPerHousehold();
        const mainValveData = stats.mainValves.find(m => m.valve.id === device.id);
        const isSubValve = device.category === 'sub';
        const parentValve = isSubValve ? valves.find(v => v.id === device.parentValveId) : null;
        const supplyInfo = supplies.find(s => s.valveId === device.id);
        
        // Get analytics and device telemetry
        const analyticsValve = analyticsState?.valves?.[device.id] || null;
        const valveDeviceTelemetry = analyticsValve?.device || resolveDeviceTelemetry(device);
        
        // Build live metrics object with real or fallback data
        const valveLiveMetrics = {
          battery: valveDeviceTelemetry?.battery !== undefined ? `${valveDeviceTelemetry.battery}%` : (info.battery || '‚Äî'),
          pressure: valveDeviceTelemetry?.pressure !== undefined ? `${valveDeviceTelemetry.pressure} PSI` : (info.pressure || '‚Äî')
        };
        
        const valveTelemetryDistance = valveDeviceTelemetry?.distance_meters ?? valveDeviceTelemetry?.distanceMeters ?? null;
        const valveDeviceTimestamp = valveDeviceTelemetry?.timestamp ? new Date(valveDeviceTelemetry.timestamp).toLocaleString() : '‚Äî';
        
        setText('sidebarTitle', `‚öôÔ∏è ${device.name}`);
        
        // Build hierarchy HTML
        let hierarchyHTML = '';
        if(mainValveData) {
          hierarchyHTML = `
            <div class="card">
              <h4><i class="fas fa-sitemap"></i> VALVE HIERARCHY</h4>
              <div class="valve-hierarchy">
                <div class="valve-item main ${device.active ? 'closed' : ''}">
                  <div class="valve-item-header">
                    <div class="valve-item-title">
                      <i class="fas fa-cog"></i>
                      ${device.name} (MAIN)
                    </div>
                    <span class="valve-item-status ${device.valveState}">${device.valveState.toUpperCase()}</span>
                  </div>
                  <div class="valve-item-info">${device.households} households total</div>
                </div>
                ${mainValveData.subValves.map(subValve => `
                  <div class="valve-item sub ${subValve.active ? 'closed' : ''}">
                    <div class="valve-item-header">
                      <div class="valve-item-title">
                        <i class="fas fa-cog" style="font-size:16px"></i>
                        ${subValve.name}
                      </div>
                      <span class="valve-item-status ${subValve.valveState}">${subValve.valveState.toUpperCase()}</span>
                    </div>
                    <div class="valve-item-info">${subValve.households} households ‚Ä¢ ${subValve.habitation}</div>
                  </div>
                `).join('')}
              </div>
            </div>
          `;
        } else if(isSubValve && parentValve) {
          hierarchyHTML = `
            <div class="card">
              <h4><i class="fas fa-sitemap"></i> VALVE HIERARCHY</h4>
              <div class="valve-hierarchy">
                <div class="valve-item main">
                  <div class="valve-item-header">
                    <div class="valve-item-title">
                      <i class="fas fa-cog"></i>
                      ${parentValve.name} (MAIN)
                    </div>
                    <span class="valve-item-status ${parentValve.valveState}">${parentValve.valveState.toUpperCase()}</span>
                  </div>
                  <div class="valve-item-info">${parentValve.households} households total</div>
                </div>
                <div class="valve-item sub ${device.active ? 'closed' : ''}">
                  <div class="valve-item-header">
                    <div class="valve-item-title">
                      <i class="fas fa-cog" style="font-size:16px"></i>
                      ${device.name} (THIS VALVE)
                    </div>
                    <span class="valve-item-status ${device.valveState}">${device.valveState.toUpperCase()}</span>
                  </div>
                  <div class="valve-item-info">${device.households} households</div>
                </div>
              </div>
            </div>
          `;
        }
        
        // Build household stats HTML
        let householdStatsHTML = '';
        const { valveTree } = calculateHouseholdStats();
        const deviceNode = valveTree.get(device.id);

        if(!device.active && deviceNode) {
          const isMainValve = device.category === 'main';
          const directHouseholds = deviceNode.directHouseholds;
          const totalHouseholds = deviceNode.totalHouseholds;
          const servedHouseholds = deviceNode.servedHouseholds;
          
          householdStatsHTML = `
            <div class="household-stats">
              <h4><i class="fas fa-home"></i> HOUSEHOLD SUPPLY</h4>
              ${isMainValve ? `
                <div class="stat-row" style="background: rgba(255,255,255,0.2); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
                  <span class="label">Total Capacity</span>
                  <span class="value">${totalHouseholds} HH</span>
                </div>
                <div class="stat-row">
                  <span class="label">Direct Households</span>
                  <span class="value">${directHouseholds} HH</span>
                </div>
                <div class="stat-row">
                  <span class="label">Sub-valve Households</span>
                  <span class="value">${totalHouseholds - directHouseholds} HH</span>
                </div>
                <div class="stat-row">
                  <span class="label">Currently Served</span>
                  <span class="value" style="color: #4caf50; font-size: 18px;">${servedHouseholds}/${totalHouseholds} HH</span>
                </div>
              ` : `
                <div class="stat-big">
                  <div class="stat-big-number">${device.households}</div>
                  <div class="stat-big-label">Households Served</div>
                </div>
              `}
              ${supplyInfo ? `
                <div class="stat-row" style="border-top: 2px solid rgba(255,255,255,0.3); padding-top: 12px; margin-top: 12px;">
                  <span class="label">Total Flow Rate</span>
                  <span class="value">${supplyInfo.totalFlow.toFixed(1)} L/min</span>
                </div>
                <div class="stat-row">
                  <span class="label">Per Household</span>
                  <span class="value">${supplyInfo.avgSupply.toFixed(2)} L/min/HH</span>
                </div>
                <div class="stat-row">
                  <span class="label">Daily Supply/HH</span>
                  <span class="value">${(supplyInfo.avgSupply * 60 * 24).toFixed(0)} L/day</span>
                </div>
              ` : ''}
            </div>
          `;
        } else if(device.active) {
          householdStatsHTML = `
            <div class="card" style="background:#fdeaea;border-color:#f7cccc">
              <h4 style="color:var(--danger)"><i class="fas fa-exclamation-triangle"></i> SUPPLY BLOCKED</h4>
              <div style="font-size:13px;color:var(--danger);font-weight:600">
                ${device.households} households are NOT receiving water supply because this valve is CLOSED.
              </div>
            </div>
          `;
        }
        
        // Build complete valve sidebar
        body.innerHTML = `
          <div class="card">
            <h4><i class="fas fa-info-circle"></i> DETAILS</h4>
            <div class="row"><span class="label">ID</span><span class="value">${info.id}</span></div>
            <div class="row"><span class="label">Type</span><span class="value">${info.type}</span></div>
            <div class="row"><span class="label">Category</span><span class="value">${info.category.toUpperCase()}</span></div>
            <div class="row"><span class="label">Households</span><span class="value">${info.households}</span></div>
            <div class="row"><span class="label">State</span><span class="value" style="color:${device.active ? 'var(--danger)' : 'var(--success)'}">${info.valveState.toUpperCase()}</span></div>
          </div>
          ${householdStatsHTML}
          ${hierarchyHTML}
          <div class="card">
            <h4><i class="fas fa-chart-line"></i> LIVE SENSORS <span class="live-indicator"></span></h4>
            <div class="row"><span class="label">Battery</span><span class="value">${valveLiveMetrics.battery}</span></div>
            <div class="row"><span class="label">Pressure</span><span class="value">${valveLiveMetrics.pressure}</span></div>
          </div>
          ${valveDeviceTelemetry ? `
          <div class="card">
            <h4><i class="fas fa-satellite-dish"></i> FIELD DEVICE</h4>
            <div class="row"><span class="label">Device ID</span><span class="value">${valveDeviceTelemetry.id || device.id}</span></div>
            <div class="row"><span class="label">Last Update</span><span class="value">${valveDeviceTimestamp}</span></div>
            ${valveTelemetryDistance !== null ? `<div class="row"><span class="label">Distance</span><span class="value">${valveTelemetryDistance.toFixed(2)} m</span></div>` : ''}
          </div>
          ` : ''}
          <div class="card">
            <h4><i class="fas fa-pipe"></i> AFFECTED PIPELINES (${affectedPipelines.length})</h4>
            ${affectedPipelines.length > 0 ? affectedPipelines.map(pipe => {
              const hasFlow = pipe.currentFlow > 0;
              const isBlocked = device.active;
              return `
                <div class="row" style="border:1px solid ${hasFlow ? '#e3f2fd' : '#ffebee'};border-radius:8px;padding:10px;margin-top:8px;background:${hasFlow ? '#f1f8ff' : '#fff5f5'}">
                  <div style="flex:1">
                    <div style="font-weight:600">${pipe.name}</div>
                    <div style="font-size:11px;color:var(--muted)">${pipe.type} ‚Ä¢ ${pipe.diameter}mm</div>
                  </div>
                  <div style="text-align:right">
                    <div style="font-size:16px;font-weight:700;color:${hasFlow ? 'var(--success)' : 'var(--danger)'}">${pipe.currentFlow.toFixed(0)} L/min</div>
                    <div style="font-size:10px;color:${isBlocked ? 'var(--danger)' : 'var(--muted)'}">${isBlocked ? '‚õî BLOCKED' : hasFlow ? '‚úì FLOWING' : '‚úó NO FLOW'}</div>
                  </div>
                </div>
              `;
            }).join('') : '<div style="text-align:center;padding:12px;color:var(--muted);font-size:12px">No pipelines connected</div>'}
          </div>
          <div class="card">
            <h4><i class="fas fa-map-marker-alt"></i> LOCATION</h4>
            <div class="row"><span class="label">Mandal</span><span class="value">${info.loc.mandal}</span></div>
            <div class="row"><span class="label">Habitation</span><span class="value">${info.loc.habitation}</span></div>
            <div class="row"><span class="label">Coordinates</span><span class="value">${info.loc.coords}</span></div>
            <button class="btn primary" onclick="map.setView([${device.lat},${device.lng}],18)"><i class="fas fa-crosshairs"></i> Center on Map</button>
          </div>
          <div class="card">
            <h4><i class="fas fa-sliders"></i> FLOW CONTROL</h4>
            <button class="btn success" onclick="setValveFlow('${device.id}', false)" ${!device.active ? 'disabled' : ''}><i class="fas fa-check"></i> Open Valve</button>
            <button class="btn danger" onclick="setValveFlow('${device.id}', true)" ${device.active ? 'disabled' : ''}><i class="fas fa-ban"></i> Close Valve</button>
          </div>
          <div class="card">
            <h4><i class="fas fa-tools"></i> ACTIONS</h4>
            <button class="btn" onclick="editValve('${device.id}')"><i class="fas fa-pen"></i> Edit Valve</button>
            <button class="btn danger" onclick="deleteValve('${device.id}')"><i class="fas fa-trash"></i> Delete</button>
          </div>
          <div class="card">
            <h4><i class="fas fa-clock-rotate-left"></i> HISTORICAL DATA</h4>
            <button class="btn primary" onclick="openHistory('${device.id}', 'valves')">
              <i class="fas fa-history"></i> View History
            </button>
          </div>
        `;
      }
      sidebar.classList.add('open');
    }

function closeSidebar() { 
  document.getElementById('sidebar').classList.remove('open');
  document.getElementById('supplyDashboard').classList.remove('shifted');
  currentSidebarDeviceId = null;
  currentSidebarDeviceType = null;
}
    async function setValveFlow(id, shouldBlock) {
  const valve = valves.find(v => v.id === id);
  if(!valve) return;
  
  valve.active = shouldBlock;
  valve.valveState = shouldBlock ? 'closed' : 'open';
  await FirebaseService.saveValve(valve);
  
  flowCacheDirty = true;
  requestDrawCanvas();
  requestSupplyDashboardUpdate();
  
  if(shouldBlock) {
    toast(`üî¥ Valve closed - ${valve.households} households affected`);
  } else {
    toast(`‚úÖ Valve opened - ${valve.households} households restored`);
  }
  
  // Check if tank sidebar is open and refresh it
  const sidebar = document.getElementById('sidebar');
  if(sidebar.classList.contains('open')) {
    const sidebarTitle = document.getElementById('sidebarTitle').textContent;
    if(sidebarTitle.includes('üèóÔ∏è')) {
      // Tank sidebar is open, find which tank and refresh
      tanks.forEach(tank => {
        if(tank.connectedMainValves && tank.connectedMainValves.includes(valve.id)) {
          showDevice(tank, 'tank');
        }
      });
    }
  }
}

    function findAffectedPipelines(valve) {
      const affected = [];
      pipelines.forEach(pipe => {
        for(let i = 0; i < pipe.points.length - 1; i++) {
          if(pointOnSegment(valve, pipe.points[i], pipe.points[i+1], POINT_R + 4)) {
            affected.push(pipe);
            break;
          }
        }
      });
      return affected;
    }

    function findConnectedPipelines(tank) {
      const connected = [];
      pipelines.forEach(pipe => {
        for(let i = 0; i < pipe.points.length - 1; i++) {
          if(pointOnSegment(tank, pipe.points[i], pipe.points[i+1], 20)) {
            connected.push(pipe);
            break;
          }
        }
      });
      return connected;
    }

    // ==================== FLOW CALCULATION (CACHED) ====================
    function isSegmentBlocked(p1, p2) {
  // A segment is blocked if there's a CLOSED valve (active=true) on it
  return valves.some(v => {
    if (!v.active) return false; // Valve is open, doesn't block
    return pointOnSegment(v, p1, p2, POINT_R + 4);
  });
}

    function connectedSegments(point, excludePi = -1, excludeSi = -1) {
      const results = [];
      pipelines.forEach((pipe, pi) => {
        for(let i = 0; i < pipe.points.length - 1; i++) {
          if(pi === excludePi && i === excludeSi) continue;
          const p1 = pipe.points[i], p2 = pipe.points[i + 1];
          if(distanceInPixels(point, p1) < CONNECT_THRESH || distanceInPixels(point, p2) < CONNECT_THRESH) {
            results.push({pi, si: i});
          }
        }
      });
      return results;
    }

    function computeFlow() {
  try {
    // Safety check for infinite loops
    if (!Array.isArray(tanks) || !Array.isArray(pipelines) || !Array.isArray(valves)) {
      console.warn('computeFlow: Invalid data structures');
      return { p: {} };
    }
    
    // Use server-computed flow if available
    if(analyticsState?.pipelines) {
      const flow = {p: {}};
      pipelines.forEach((pipe, pi) => {
        const serverFlow = analyticsState.pipelines[pipe.id];
        if(serverFlow) {
          flow.p[pi] = { s: serverFlow.segments || {} };
          pipe.currentFlow = serverFlow.currentFlow || 0;
        } else {
          pipe.currentFlow = 0;
        }
      });
      flowCache = flow;
      flowCacheDirty = false;
      return flow;
    }

    if(!flowCacheDirty && flowCache) return flowCache;
    
    const flow = {p: {}};
    if(tanks.length === 0 || pipelines.length === 0) { 
      flowCache = flow; 
      flowCacheDirty = false; 
      return flow; 
    }

    const starts = [];
    tanks.forEach(tank => {
      if (!tank || !tank.lat || !tank.lng) return;
      
      pipelines.forEach((pipe, pi) => {
        if (!pipe || !pipe.points || !Array.isArray(pipe.points)) return;
        
        for(let i = 0; i < pipe.points.length - 1; i++) {
          if(pointOnSegment(tank, pipe.points[i], pipe.points[i + 1], 20)) {
            starts.push({pi, si: i});
          }
        }
      });
    });

    if(starts.length === 0) { 
      flowCache = flow; 
      flowCacheDirty = false; 
      return flow; 
    }

    const seen = new Set();
    const queue = [...starts];
    let iterations = 0;
    const maxIterations = 1000; // REDUCED from 10000 to prevent long hangs

    while(queue.length > 0 && iterations < maxIterations) {
      iterations++;
      const current = queue.shift();
      const key = `${current.pi}-${current.si}`;
      if(seen.has(key)) continue;
      seen.add(key);

      // Add progress warning
      if (iterations % 200 === 0) {
        console.warn(`‚ö†Ô∏è computeFlow: ${iterations} iterations processed`);
      }

      const pipe = pipelines[current.pi].points;
      const p1 = pipe[current.si];
      const p2 = pipe[current.si + 1];
      
      // Check if blocked by closed valve
      const blocked = isSegmentBlocked(p1, p2);

      if(!flow.p[current.pi]) flow.p[current.pi] = {s: {}};
      flow.p[current.pi].s[current.si] = {
        hasFlow: !blocked,
        blocked: blocked
      };
      
      if(!blocked) {
        if(current.si + 1 < pipe.length - 1) queue.push({pi: current.pi, si: current.si + 1});
        if(current.si - 1 >= 0) queue.push({pi: current.pi, si: current.si - 1});
        
        [p1, p2].forEach(endpoint => {
          connectedSegments(endpoint, current.pi, current.si).forEach(neighbor => {
            const neighborKey = `${neighbor.pi}-${neighbor.si}`;
            if(!seen.has(neighborKey)) queue.push(neighbor);
          });
        });
      }
    }
    
    if (iterations >= maxIterations) {
      console.error('‚ùå computeFlow hit iteration limit - possible circular pipeline!');
      toast('‚ö†Ô∏è Pipeline network too complex - some flow data may be incomplete');
    }

    pipelines.forEach((pipe, pi) => {
      if(flow.p[pi]) {
        const flowingSegments = Object.values(flow.p[pi].s).filter(s => s.hasFlow).length;
        const totalSegments = pipe.points.length - 1;
        pipe.currentFlow = totalSegments > 0 ? (flowingSegments / totalSegments) * pipe.capacity : 0;
      } else {
        pipe.currentFlow = 0;
      }
    });

    flowCache = flow;
    flowCacheDirty = false;
    return flow;
    
  } catch (error) {
    console.error('‚ùå Error in computeFlow:', error);
    return { p: {} };
  }
}

    // ==================== DRAWING ====================
    let drawRequested = false;
    function requestDrawCanvas() {
      if(drawRequested) return;
      drawRequested = true;
      requestAnimationFrame(() => {
        drawCanvas();
        drawRequested = false;
      });
    }

    function drawCanvas() {
      const now = performance.now();
      if(now - lastDrawTime < DRAW_THROTTLE) return;
      lastDrawTime = now;
      if(!ctx || !map) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const flow = computeFlow();

      // Pipelines
      // Pipelines
      pipelines.forEach((pipe, pi) => {
        for(let i = 0; i < pipe.points.length - 1; i++) {
          const p1 = pipe.points[i];
          const p2 = pipe.points[i + 1];
          const stat = flow.p[pi]?.s[i];
          const hasFlow = !!stat?.hasFlow;
          const blocked = !!stat?.blocked;
          const connected = stat !== undefined;

          // Default: gray for unconnected segments
          let color = '#b0b9c4';
          let glow = 'rgba(176,185,196,0.4)';
          let lineWidth = LINE_W;
          
          if(connected) {
            if(blocked) { 
              // Red: segment is connected but blocked by a closed valve
              color = '#d32f2f'; 
              glow = 'rgba(211,47,47,0.6)'; 
            }
            else if(hasFlow) { 
              // Blue: segment is connected and has active flow
              color = '#1e88e5'; 
              glow = 'rgba(30,136,229,0.6)'; 
            }
            else {
              // Green/cyan: segment is connected but no flow (no blocking valve, but no water source reaching it)
              color = '#4caf50'; 
              glow = 'rgba(76,175,80,0.4)';
            }
          }
          if(mode === 'erase' && hoveredDevice?.type === 'pipeline') {
            const hoveredPipe = hoveredDevice.data.pipe;
            const hoveredSegment = hoveredDevice.data.segmentIndex;
            if(hoveredPipe.id === pipe.id && hoveredSegment === i) {
              color = '#ff6b6b';
              glow = 'rgba(255,107,107,0.8)';
              lineWidth = LINE_W + 2;
            }
          }

          const a = latLngToPixel(p1);
          const b = latLngToPixel(p2);

          ctx.shadowColor = glow;
          ctx.shadowBlur = 14;
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
          ctx.shadowBlur = 0;
        }

        if(pipe.currentFlow > 0 && pipe.points.length > 0) {
          const midPoint = pipe.points[Math.floor(pipe.points.length / 2)];
          const px = latLngToPixel(midPoint);
          ctx.fillStyle = 'rgba(30,136,229,0.9)';
          ctx.font = 'bold 11px Inter, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = 'rgba(0,0,0,0.3)';
          ctx.shadowBlur = 4;
          const flowText = `${pipe.currentFlow.toFixed(0)} L/min`;
          ctx.fillText(flowText, px.x, px.y - 12);
          ctx.shadowBlur = 0;
        }
      });

      // Current pipeline drawing
      if(currentPipeline.length > 1) {
        ctx.strokeStyle = '#9aa7b5';
        ctx.lineWidth = LINE_W;
        ctx.shadowColor = 'rgba(154,167,181,0.5)';
        ctx.shadowBlur = 8;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        const start = latLngToPixel(currentPipeline[0]);
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        for(let i = 1; i < currentPipeline.length; i++) {
          const p = latLngToPixel(currentPipeline[i]);
          ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      // Valves
      valves.forEach(valve => {
        const p = latLngToPixel(valve);
        const hovered = hoveredDevice?.device === valve;
        const scale = hovered ? 1.3 : 1.0;
        const size = 32 * scale;
        ctx.shadowColor = valve.active ? 'rgba(211,47,47,0.5)' : 'rgba(106,27,154,0.5)';
        ctx.shadowBlur = 16;
        if(ImageCache.loaded && ImageCache.valve) {
          ctx.drawImage(ImageCache.valve, p.x - size / 2, p.y - size / 2, size, size);
        } else {
          ctx.fillStyle = valve.active ? '#d32f2f' : '#6a1b9a';
          ctx.beginPath(); ctx.arc(p.x, p.y, 12 * scale, 0, Math.PI * 2); ctx.fill();
        }
        ctx.shadowBlur = 0;
        if(valve.households > 0) {
          const badgeRadius = 10 * scale;
          const badgeX = p.x + (size / 2) - badgeRadius;
          const badgeY = p.y - (size / 2) + badgeRadius;
          ctx.fillStyle = valve.active ? '#d32f2f' : '#6a1b9a';
          ctx.beginPath(); ctx.arc(badgeX, badgeY, badgeRadius, 0, Math.PI * 2); ctx.fill();
          ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(badgeX, badgeY, badgeRadius, 0, Math.PI * 2); ctx.stroke();
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 11px Inter, sans-serif';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText(valve.households, badgeX, badgeY);
        }
      });

      // Tanks
      tanks.forEach(tank => {
        const p = latLngToPixel(tank);
        const hovered = hoveredDevice?.device === tank;
        const scale = hovered ? 1.3 : 1.0;
        const size = 40 * scale;
        ctx.shadowColor = 'rgba(2,136,209,0.5)';
        ctx.shadowBlur = 20;
        if(ImageCache.loaded && ImageCache.waterTower) {
          ctx.drawImage(ImageCache.waterTower, p.x - size / 2, p.y - size / 2, size, size);
        } else {
          ctx.fillStyle = '#0288d1';
          ctx.beginPath(); ctx.arc(p.x, p.y, 14 * scale, 0, Math.PI * 2); ctx.fill();
          ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 3;
          ctx.beginPath(); ctx.arc(p.x, p.y, 14 * scale, 0, Math.PI * 2); ctx.stroke();
        }
        ctx.shadowBlur = 0;
      });
    }

    // ==================== GENERAL UTILS ====================
    function bindBtn(id, fn) {
      const el = document.getElementById(id);
      if(el) el.addEventListener('click', fn);
      else console.warn(`Button with id "${id}" not found`);
    }
    function setActive(id, active) { const el = document.getElementById(id); if(el) el.classList.toggle('active', active); }
    function setText(id, text) { const el = document.getElementById(id); if(el) el.textContent = text; }
    function setValue(id, value) { const el = document.getElementById(id); if(el) el.value = value; }
    function val(id) { const el = document.getElementById(id); return el ? el.value : ''; }
    function openModal(id) { const el = document.getElementById(id); if(el) el.classList.add('active'); }
    function closeModal(id) {
      const el = document.getElementById(id);
      if(el) {
        el.classList.remove('active');
        if(id === 'pipelineModal' && mode === 'pipeline') {
          map.dragging.disable();
          map.scrollWheelZoom.disable();
        }
      }
    }
    function eventToPixel(e) {
      const rect = canvas.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }
    function pixelToLatLng(pixel) {
      const point = map.containerPointToLatLng([pixel.x, pixel.y]);
      return {lat: point.lat, lng: point.lng};
    }
    function latLngToPixel(latLng) {
      const point = map.latLngToContainerPoint([latLng.lat, latLng.lng]);
      return {x: point.x, y: point.y};
    }
    function distanceBetweenPixels(p1, p2) { return Math.hypot(p2.x - p1.x, p2.y - p1.y); }
    function distanceInPixels(latLng1, latLng2) {
      const p1 = latLngToPixel(latLng1);
      const p2 = latLngToPixel(latLng2);
      return distanceBetweenPixels(p1, p2);
    }
    function pointOnSegment(point, a, b, threshold) {
      const P = latLngToPixel(point);
      const A = latLngToPixel(a);
      const B = latLngToPixel(b);
      const APx = P.x - A.x, APy = P.y - A.y;
      const ABx = B.x - A.x, ABy = B.y - A.y;
      const ab2 = ABx * ABx + ABy * ABy;
      if(ab2 === 0) return distanceBetweenPixels(P, A) < threshold;
      let t = (APx * ABx + APy * ABy) / ab2;
      t = Math.max(0, Math.min(1, t));
      const proj = { x: A.x + ABx * t, y: A.y + ABy * t };
      return distanceBetweenPixels(P, proj) < threshold;
    }
    function isOnAnyPipeline(latLng, threshold) {
      for(let pipe of pipelines) {
        for(let i = 1; i < pipe.points.length; i++) {
          if(pointOnSegment(latLng, pipe.points[i - 1], pipe.points[i], threshold)) return true;
        }
      }
      return false;
    }

    // ==================== EXPOSE GLOBALS FOR UI CALLBACKS ====================
    window.openHistory = openHistory;
    window.loadHistory = loadHistory;
    window.exportCurrentHistory = exportCurrentHistory;
    window.map = map;
    window.editTank = editTank;
    window.editValve = editValve;
    window.deleteTank = deleteTank;
    window.deleteValve = deleteValve;
    window.deletePipeline = deletePipeline;
    window.editPipeline = editPipeline;
    window.centerPipeline = centerPipeline;
    window.viewTank = viewTank;
    window.viewValve = viewValve;
    window.viewDevice = viewDevice;
    window.setValveFlow = setValveFlow;
    window.switchMapLayer = switchMapLayer;
    
   

  </script>
</body>
</html>
